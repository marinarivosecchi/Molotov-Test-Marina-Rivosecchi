# -*- coding: utf-8 -*-
"""Molotov Test - Marina Rivosecchi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i22166VXYfs53aE4oJJ2xYmPbWFvc3UE

# Import libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# Import all packages and set plots to be embedded inline
import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns

# %matplotlib inline

# Suppress warnings from final output
import warnings
warnings.simplefilter("ignore")

# Load drive
from google.colab import drive
drive.mount('/content/drive')

"""# Data Preparation

"""

# Load data

df1 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/channel.csv').iloc[:, 1:]
channel_data = df1

df2 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/subscriptions.csv').iloc[:, 1:]
subscriptions_data = df2

df3 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/users.csv').iloc[:, 1:]
users_data = df3

df4 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/watch.csv').iloc[:, 1:]
watch_data = df4

"""## Preview data"""

channel_data.head()

subscriptions_data.head()

users_data.head()

watch_data.head()

"""## Check datatypes and adjust"""

channel_data.info()

channel_data['NAME'] = channel_data['NAME'].astype('string')
channel_data.info()

subscriptions_data.info()

subscriptions_data['USER_ID'] = subscriptions_data['USER_ID'].astype('string')
subscriptions_data['SUBSCRIPTION_BEGIN_DATE'] = pd.to_datetime(subscriptions_data['SUBSCRIPTION_BEGIN_DATE'])
subscriptions_data['SUBSCRIPTION_END_DATE'] = pd.to_datetime(subscriptions_data['SUBSCRIPTION_END_DATE'])
subscriptions_data['PRODUCT_NAME'] = subscriptions_data['PRODUCT_NAME'].astype('string')

subscriptions_data.info()

users_data['ID'] = users_data['ID'].astype('string')
users_data['BIRTHDAY'] = pd.to_datetime(users_data['BIRTHDAY'])
users_data['ACCOUNT_CREATION_DATE'] = pd.to_datetime(users_data['ACCOUNT_CREATION_DATE'])

users_data.info()

watch_data['DATE_DAY'] = pd.to_datetime(watch_data['DATE_DAY'])
watch_data['USER_ID'] = watch_data['USER_ID'].astype('string')
watch_data['DEVICE_TYPE'] = watch_data['DEVICE_TYPE'].astype('string')
watch_data['PROGRAM_KIND'] = watch_data['PROGRAM_KIND'].astype('string')
watch_data['ASSET_TYPE'] = watch_data['ASSET_TYPE'].astype('string')
watch_data['DURATION'] = watch_data['DURATION'].astype('float64')
watch_data['CHANNEL_ID'] = watch_data['CHANNEL_ID'].astype('float64')
watch_data['EVENT_ID'] = watch_data['EVENT_ID'].fillna(0)
watch_data['EVENT_ID'] = watch_data['EVENT_ID'].astype('int64')

watch_data.info()

"""## Check duplicates, null, unique values and descriptive stats"""

# CHANNEL
# Check for duplicates
duplicates_channel = channel_data.duplicated().sum()
print("Number of duplicate rows in Channel:", duplicates_channel)

# Check for null or missing values
null_values_channel = channel_data.isnull().sum()
print("\nNull values in Channel:")
print(null_values_channel)

# Check unique values
unique_values_channel = channel_data.nunique()
print("\nUnique values in Channel:")
print(unique_values_channel)

# Explore descriptive statistics
channel_statistics = channel_data.describe()
print("\nDescriptive statistics in Channel:")
print(channel_statistics)

# SUBSCRIPTIONS
# Check for duplicates
duplicates_subscription = subscriptions_data.duplicated().sum()
print("Number of duplicate rows in Subscription:", duplicates_subscription)

# Check for null or missing values
subscription_null_values = subscriptions_data.isnull().sum()
print("\nNull values in Subscription:")
print(subscription_null_values)

# Check unique values
unique_subscription_values = subscriptions_data.nunique()
print("\nUnique values in Subscription:")
print(unique_subscription_values)

# Explore descriptive statistics
subscription_statistics = subscriptions_data.describe()
print("\nDescriptive statistics in Subscription:")
print(subscription_statistics)

# USERS

# Check for duplicates
user_duplicates = users_data.duplicated().sum()
print("Number of duplicate rows in User:", user_duplicates)

# Check for null or missing values
user_null_values = users_data.isnull().sum()
print("\nNull values in User:")
print(user_null_values)

# Check unique values
user_unique_values = users_data.nunique()
print("\nUnique values in User:")
print(user_unique_values)

# Explore descriptive stats
user_statistics = users_data.describe()
print("\nDescriptive statistics in User:")
print(user_statistics)

# WATCH

# Check for duplicates
duplicates_watch = watch_data.duplicated().sum()
print("Number of duplicate rows in Watch:", duplicates_watch)

# Check for null or missing values
watch_null_values = watch_data.isnull().sum()
print("\nNull values in Watch:")
print(watch_null_values)

# Check unique values
watch_unique_values = watch_data.nunique()
print("\nUnique values in Watch:")
print(watch_unique_values)

# Explore descriptive statistics
watch_statistics = watch_data.describe()
print("\nDescriptive statistics in Watch:")
print(watch_statistics)

"""# Data exploration"""

# Calculate totals
total_users = users_data.shape[0]
total_events = watch_data.shape[0]
total_channels = channel_data.shape[0]

print("Total users:", total_users)
print("Total events:", total_events)
print("Total channels:", total_channels)

# Values for device type
print(watch_data['DEVICE_TYPE'].unique())

"""## Stats by device type"""

# Group by device type
watch_grouped_device = watch_data.groupby("DEVICE_TYPE")

# Dictionary to save results
results = {}

# Calculate metrics for each device type
for DEVICE_TYPE in watch_grouped_device.groups.keys():

    df = watch_grouped_device.get_group(DEVICE_TYPE)
    unique_users_device = df["USER_ID"].nunique()
    sessions_device = df.shape[0]
    avg_duration = df["DURATION"].mean() / 60 # Convert a minutes
    share_users = (unique_users_device / total_users) * 100
    share_sessions = (sessions_device / total_events) * 100

    results[DEVICE_TYPE] = {
        "Unique users": unique_users_device,
        "Total events": sessions_device,
        "AVG Duration (min)": avg_duration,
        "Users Share": share_users,
        "Events Share": share_sessions,
    }

# Convert results to DataFrame
results_df = pd.DataFrame(results).T  # Transpose the DataFrame to have devices as rows

# Format numeric values with comma separators and no decimal places
results_df["Unique users"] = results_df["Unique users"].apply(lambda x: "{:,.0f}".format(x))
results_df["Total events"] = results_df["Total events"].apply(lambda x: "{:,.0f}".format(x))
results_df["AVG Duration (min)"] = results_df["AVG Duration (min)"].apply(lambda x: "{:,.2f}".format(x))
results_df["Users Share"] = results_df["Users Share"].apply(lambda x: "{:.2f}%".format(x))
results_df["Events Share"] = results_df["Events Share"].apply(lambda x: "{:.2f}%".format(x))


# Show the sorted results DataFrame
print(results_df.to_string(index=True))
print()
print("Note: The device with the most users is TV, followed by the phone.")

# Sort DataFrame by Unique users in descending order
results_df = results_df.sort_values(by="Unique users", ascending=False)

# Define the figure and axes
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))

# Plot unique users
results_df["Unique users"].str.replace(',', '').astype(float).plot(kind='bar', ax=ax1, color='skyblue', width=0.4, position=0, label='Utilisateurs uniques')
ax1.set_xlabel('Type de dispositif')
ax1.set_ylabel('Nombre')
ax1.set_title('Utilisateurs uniques par type de dispositif')
ax1.set_xticklabels(results_df.index, rotation=45)
ax1.legend()

# Plot total events
results_df["Total events"].str.replace(',', '').astype(float).plot(kind='bar', ax=ax2, color='lightgreen', width=0.4, position=1, label='Événements totaux')
ax2.set_xlabel('Type de dispositif')
ax2.set_ylabel('Nombre')
ax2.set_title('Événements totaux par type de dispositif')
ax2.set_xticklabels(results_df.index, rotation=45)
ax2.legend()

# Show plot
plt.tight_layout()
plt.show()

# Group by device type
watch_grouped_device = watch_data.groupby("DEVICE_TYPE")

# Dictionary to save results
results = {}

# Calculate metrics for each device type
for DEVICE_TYPE in watch_grouped_device.groups.keys():
    df = watch_grouped_device.get_group(DEVICE_TYPE)
    avg_duration = df["DURATION"].mean() / 60  # Convert to minutes
    results[DEVICE_TYPE] = avg_duration

# Convert results to DataFrame
results_df = pd.DataFrame(results, index=['Average Duration']).T

# Sort dataframe
results_df = results_df.sort_values(by='Average Duration', ascending=False)

# Reset index
results_df.reset_index(inplace=True)

# Create histogram
plt.figure(figsize=(6, 4))
barplot = sns.barplot(data=results_df, x='index', y='Average Duration', color='#2a38d9')

# Adjust bars
bar_width = 0.8
for patch in barplot.patches:
    patch.set_width(bar_width)

# Include labels
for index, row in results_df.iterrows():
    barplot.text(index, row['Average Duration'], f'{int(row["Average Duration"])} min', color='black', ha='center', va='bottom')

# Include axes labels
plt.xlabel('Device type')

# Move the title upwards
plt.title('Average Viewing Duration by Device Type', )

# Adjust text positions
plt.tick_params(axis='x', which='major', pad=10)

# Remove Y-axis
plt.gca().axes.get_yaxis().set_visible(False)

# Remove grid lines
plt.grid(False)

# Remove box around the plot
plt.box(on=None)

# Add a horizontal line at the bottom of the bars
plt.axhline(y=0, color='black', linewidth=2)

# Rotate texts
plt.xticks(rotation=0, ha='center')

# Show plot
plt.show()

# Calculate average duration for each device type
device_avg_duration = results_df.set_index('index').to_dict()['Average Duration']

# Calculate overall average duration
overall_avg_duration = (watch_data['DURATION'].mean())/60

# Print average duration for each device type
print("Average Duration by Device Type:")
for device_type, avg_duration in device_avg_duration.items():
    print(f"{device_type}: {avg_duration:.2f} min")

# Print overall average duration
print(f"\nOverall Average Duration: {overall_avg_duration:.2f} min")

"""## Visualizations per day and month"""

# Merge watch_data with user_data
merged_data = pd.merge(watch_data, users_data, left_on='USER_ID', right_on='ID', how='left')

# Extract hour, day of the week, month, and year from the timestamp
merged_data['Day_of_Week'] = merged_data['DATE_DAY'].dt.dayofweek  # Monday=0, Sunday=6
merged_data['Month'] = merged_data['DATE_DAY'].dt.month
merged_data['Year'] = merged_data['DATE_DAY'].dt.year

# Calculate the average number of users for each day of the week
daily_avg_users = merged_data.groupby('Day_of_Week')['USER_ID'].nunique()

# Calculate the average number of users for each month
monthly_avg_users = merged_data.groupby('Month')['USER_ID'].nunique()
# Calculate the average number of users for each year
yearly_avg_users = merged_data.groupby('Year')['USER_ID'].nunique()

# Create a figure and axes for the plots
fig, axes = plt.subplots(1, 3, figsize=(20, 6))

# Plot for distribution per day of the week
days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
axes[0].plot(days_of_week, daily_avg_users.values, color='lightgreen', marker='o', linestyle='-')
axes[0].set_title('Distribution per Day of the Week')
axes[0].set_xlabel('Day of the Week')
axes[0].set_ylabel('Average Number of Users')

# Plot for distribution per month
axes[1].plot(monthly_avg_users.index, monthly_avg_users.values, color='salmon', marker='o', linestyle='-')
axes[1].set_title('Distribution per Month')
axes[1].set_xlabel('Month')
axes[1].set_ylabel('Average Number of Users')
axes[1].set_xticks(range(1, 13))  # Show all months on the x-axis

# Plot for distribution per year
axes[2].plot(yearly_avg_users.index, yearly_avg_users.values, color='gold', marker='o', linestyle='-')
axes[2].set_title('Distribution per Year')
axes[2].set_xlabel('Year')
axes[2].set_ylabel('Average Number of Users')

# Adjust layout and show the plots
plt.tight_layout()
plt.show()

"""## Divide by device type"""

# Define colors
colors = {
    'tv': '#ff7b7a',
    'phone': '#2078b4',
    'desktop': '#a8cfe4',
    'tablet': '#35a12f',
    'smart_display': '#b2df8a'
}


plt.figure(figsize=(8, 2))
for i, (device, color) in enumerate(colors.items()):
    plt.fill_between([i, i+1], 0, 1, color=color, label=device)
plt.xticks([])
plt.yticks([])
plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1), ncol=5)
plt.show()

# Set the color palette
sns.set_palette("Paired")

# Calculate the average number of users for each day of the week and device type
daily_avg_users = merged_data.groupby(['Day_of_Week', 'DEVICE_TYPE'])['USER_ID'].nunique()

# Calculate the average number of users for each month and device type
monthly_avg_users = merged_data.groupby(['Month', 'DEVICE_TYPE'])['USER_ID'].nunique()

# Create a figure and axes for the plots
fig, axes = plt.subplots(1, 2, figsize=(15, 6))

# Plot for distribution per day of the week and device type
for device_type, data in daily_avg_users.groupby(level='DEVICE_TYPE'):
    axes[0].plot(data.index.get_level_values('Day_of_Week'), data.values, marker='o', linestyle='-', label=device_type)

axes[0].set_title('Distribution par jour de la semaine par type de dispositif', fontsize=16, y=1.05)
axes[0].set_xlabel('Jour de la semaine', fontsize=16)
axes[0].set_ylabel('Nombre moyen d\'utilisateurs', fontsize=16)
axes[0].set_xticks(range(7))
axes[0].set_xticklabels(['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'], fontsize=13)
axes[0].tick_params(axis='y', labelsize=14)


# Plot for distribution per month and device type
for device_type, data in monthly_avg_users.groupby(level='DEVICE_TYPE'):
    axes[1].plot(data.index.get_level_values('Month'), data.values, marker='o', linestyle='-', label=device_type)

axes[1].set_title('Distribution par mois par type de dispositif', fontsize=16, y=1.05)
axes[1].set_xlabel('Mois', fontsize=16)
axes[1].set_ylabel('', fontsize=16)
axes[1].set_xticks(range(1, 13))
axes[1].tick_params(axis='y', labelsize=14)
axes[1].set_xticklabels(['Jan', 'Fev', 'Mar', 'Avr', 'Mai', 'Jun', 'Jul', 'Aou', 'Sep', 'Oct', 'Nov', 'Dec'], fontsize=14)
axes[1].tick_params(axis='y', labelsize=14)  # Ajustar el tamaño de las etiquetas del eje Y

# Sacar el cuadro de leyenda para los dos gráficos
handles, labels = axes[1].get_legend_handles_labels()
fig.legend(handles, labels, loc='lower center', bbox_to_anchor=(0.5, -0.1), fontsize=16,ncol=5)

# Ajustar layout y mostrar los gráficos
plt.show()

# Set the color palette
sns.set_palette("Paired")

# Calculate the average number of users for each day of the week and device type
daily_avg_users = merged_data.groupby(['Day_of_Week', 'DEVICE_TYPE'])['USER_ID'].nunique()

# Create figure and axes for the plot
fig, ax = plt.subplots(figsize=(12, 6))

# Plot for distribution per day of the week and device type
for device_type, data in daily_avg_users.groupby(level='DEVICE_TYPE'):
    line = ax.plot(data.index.get_level_values('Day_of_Week'), data.values, marker='o', linestyle='-', label=device_type)
    # Add legend text next to the line with the same color
    last_value = data.values[-1]
    color = line[0].get_color()  # Get color of the line
    ax.text(data.index.get_level_values('Day_of_Week')[-1] + 0.3, last_value, device_type, fontsize=18, color=color, verticalalignment='center', horizontalalignment='left')

ax.set_title('Distribution par jour de la semaine par type de dispositif', fontsize=18, y=1.05)
ax.set_ylabel('Nombre moyen d\'utilisateurs', fontsize=18)
ax.set_xticks(range(7))
ax.set_xticklabels(['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'], fontsize=18)
ax.tick_params(axis='y', labelsize=18)

# Remove top and right spines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Show the plot
plt.tight_layout()
plt.show()

"""### Asset types count by device type

"""

import plotly.express as px

# View count for each content type and device type
content_views = merged_data.groupby(['ASSET_TYPE', 'DEVICE_TYPE']).size().reset_index(name='count')

# Number of views for each device type and the overall total views
total_views_per_device = content_views.groupby('DEVICE_TYPE')['count'].sum()
total_views = total_views_per_device.sum()

# Calculate the percentage of each content type relative to its device's total and the overall total views
content_views['Percentage_Device'] = content_views.apply(lambda row: f"{(row['count'] / total_views_per_device[row['DEVICE_TYPE']] * 100):.2f}%", axis=1)
content_views['Percentage_Total'] = content_views.apply(lambda row: f"{(row['count'] / total_views * 100):.2f}%", axis=1)

# Sort the results in descending order based on view count and device type
content_views_sorted = content_views.sort_values(by=['DEVICE_TYPE', 'count'], ascending=[True, False])

custom_color_scale = [
    [0.0, 'rgb(255, 266, 128)'],
    [0.5, 'rgb(255, 230, 0)'],
    [1.0, 'rgb(255, 134, 0)']
]

# Create the Sunburst Plot
fig = px.sunburst(content_views_sorted,
                  path=['DEVICE_TYPE', 'ASSET_TYPE'],
                  values='count',
                  title='Top 10 Vues de contenu par type de dispositif',
                  color='count',  # Color by view count
                  color_continuous_scale=custom_color_scale,  # Color scale
                  branchvalues='total',  # 'total' to show total views at each level
                  labels={'count': 'Views', 'DEVICE_TYPE': 'Device Type', 'ASSET_TYPE': 'Asset Type'})  # Add labels

fig.update_layout(font=dict(size=12))
# Show the plot
fig.show()

# Sort the device types by total views from highest to lowest
sorted_device_types = total_views_per_device.sort_values(ascending=False).index

# Select the top 10 most viewed content types for each device type
top_content_per_device = content_views_sorted.groupby('DEVICE_TYPE').head(15)

# Display these results in a table, dividing it into sections for each device type
for device_type in sorted_device_types:
    data = top_content_per_device[top_content_per_device['DEVICE_TYPE'] == device_type]
    total_views_device = total_views_per_device[device_type]
    print(f"Top 10 Content for {device_type} (Total Views: {total_views_device}):")
    print(data[['ASSET_TYPE', 'count', 'Percentage_Device', 'Percentage_Total']].to_string(index=False))
    print("\n")

"""### Program kind count by device type

"""

# Calculate the view count for each program type and device type
content_views = merged_data.groupby(['DEVICE_TYPE', 'PROGRAM_KIND']).size().reset_index(name='count')

# Calculate the total number of views for each device type and the overall total views
total_views_per_device = content_views.groupby('DEVICE_TYPE')['count'].sum()
total_views = total_views_per_device.sum()

# Calculate the percentage of each content type relative to its device's total and the overall total views
content_views['Percentage_Device'] = content_views.apply(lambda row: row['count'] / total_views_per_device[row['DEVICE_TYPE']] * 100, axis=1)
content_views['Percentage_Total'] = content_views.apply(lambda row: row['count'] / total_views * 100, axis=1)

# Sort the results in descending order
content_views_sorted = content_views.sort_values(by=['DEVICE_TYPE', 'count'], ascending=[True, False])

# Select the top 10 most viewed content types for each device type
top_content_per_device = content_views_sorted.groupby('DEVICE_TYPE').head(10)

custom_color_scale = [
    [0.0, 'rgb(255, 266, 128)'],
    [0.5, 'rgb(255, 230, 0)'],
    [1.0, 'rgb(255, 134, 0)']
]

# Create the Sunburst Plot
fig = px.sunburst(top_content_per_device,
                  path=['DEVICE_TYPE', 'PROGRAM_KIND'],
                  values='count',
                  title='Top 10 Program Kind Views by Device Type',
                  color='count',
                  color_continuous_scale = custom_color_scale,
                  branchvalues='total',
                  labels={'count': 'Views', 'DEVICE_TYPE': 'Device Type', 'PROGRAM_KIND': 'Program Kind'})  # Add labels)

fig.update_layout(font=dict(size=12))  # Tamaño de fuente deseado

# Plot graph
fig.show()

# Sort the results
content_views_sorted = content_views.sort_values(by=['DEVICE_TYPE', 'count'], ascending=[True, False])

# Select the top 10 most viewed content types for each device type
top_content_per_device = content_views_sorted.groupby('DEVICE_TYPE').head(10)

# Display results
for device_type in sorted_device_types:
    data = top_content_per_device[top_content_per_device['DEVICE_TYPE'] == device_type]
    total_views_device = total_views_per_device[device_type]
    print(f"Top 10 Program Kind for {device_type} (Total Views: {total_views_device}):")
    # Format the percentages with 2 decimals and include the '%' symbol
    data['Percentage_Device'] = data['Percentage_Device'].apply(lambda x: f"{x:.2f}%")
    data['Percentage_Total'] = data['Percentage_Total'].apply(lambda x: f"{x:.2f}%")
    print(data[['PROGRAM_KIND', 'count', 'Percentage_Device', 'Percentage_Total']].to_string(index=False))
    print("\n")

"""# TV regular users statts"""

# Identify users who never watch on TV and those who watch regularly
never_watch_tv_users = watch_data[watch_data['DEVICE_TYPE'] != 'tv']['USER_ID'].unique()
tv_watchers = watch_data[watch_data['DEVICE_TYPE'] == 'tv']['USER_ID'].unique()

# Calculate the total number of users
watch_users = len(watch_data['USER_ID'].unique())

# Calculate the percentage of each group relative to the total number of users
percentage_never_watch_tv = (len(never_watch_tv_users) / watch_users) * 100
percentage_tv_watchers = (len(tv_watchers) / watch_users) * 100

# Print summary of findings
print(f"Number of users who never watch on TV: {len(never_watch_tv_users)} ({percentage_never_watch_tv:.2f}%)")
print(f"Number of users who have watched on TV: {len(tv_watchers)} ({percentage_tv_watchers:.2f}%)")

# Convert 'DATE_DAY' to datetime format
watch_data['DATE_DAY'] = pd.to_datetime(watch_data['DATE_DAY'])

# Extract month from the 'DATE_DAY' column
watch_data['MONTH'] = watch_data['DATE_DAY'].dt.to_period('M')

# Filter to include only the last 3 months
last_x_months = pd.PeriodIndex(watch_data['MONTH'].unique())[-3:]

# Filter the watch data
watch_data_last_x_months = watch_data[watch_data['MONTH'].isin(last_x_months)]

# Filter watch data for tv users
tv_users_over_x_hours = watch_data_last_x_months[watch_data_last_x_months['DEVICE_TYPE'] == 'tv']

# Filter to include only users who watched at least 4 hours
tv_users_over_x_hours = tv_users_over_x_hours.groupby(['USER_ID', 'MONTH']).filter(lambda x: (x['DURATION'].sum() >= 6*60*60))

# Retrieve the unique users who watched at least 4 hours
tv_unique_users_over_x_hours = tv_users_over_x_hours['USER_ID'].unique()

# Calculate the total number of users
total_users = total_users
total_tv_regular_users = len(tv_unique_users_over_x_hours)
total_tv_users = len(watch_data[watch_data['DEVICE_TYPE'] == 'tv']['USER_ID'].unique())

# Calculate percentage of selected users
regular_tv_users_percentage = round((total_tv_regular_users / total_users) * 100, 2)
regular_tv_users_tv_percentage = round((total_tv_regular_users / total_tv_users) * 100, 2)

# Print the count and percentage of selected users
print("Users who watched at least 6 hours of television each month in the last 3 months of data:")
print("Count:", total_tv_regular_users)
print("Percentage of users: ", regular_tv_users_percentage, "%")
print("Percentage of TV users: ", regular_tv_users_tv_percentage, "%")

"""### Create AGE and AGE GROUP columns for comparing"""

# Define age ranges for grouping
age_ranges = [(0, 18), (18, 25), (25, 35), (35, 45), (45, 60), (60, 95)]

# Define age labels
age_labels = ["0-18 years", "18-25 years", "25-35 years", "35-45 years", "45-60 years", "60-95 years"]

# Filter for Valid Birthdays
users_data_cleaned = users_data[users_data['BIRTHDAY'].notna()]

# Calculate Age in Years
users_data_cleaned['AGE'] = (pd.to_datetime('now') - pd.to_datetime(users_data_cleaned['BIRTHDAY'])).dt.days // 365

# Filter for valid ages (considering age <= 95)
users_data_cleaned = users_data_cleaned[users_data_cleaned['AGE'] <= 95]

# Create 'AGE_GROUP' column based on age ranges and labels
users_data_cleaned['AGE_GROUP'] = pd.cut(users_data_cleaned['AGE'], bins=[x[0] for x in age_ranges] + [95], labels=age_labels)


# Total Users and Unique Watchers
# Total users: total_users
# Unique watchers: unique_users_watch_list
# Total unique watchers: unique_users_watch

"""## Create groups for analyzing distributions and differences

### Program kind, watch days, age groups
"""

# Filter regular TV users and users that never watched in TV
regular_tv_users = tv_users_over_x_hours

# Filter users that never watched TV
all_users = set(watch_data['USER_ID'])
tv_users = set(watch_data[watch_data['DEVICE_TYPE'] == 'tv']['USER_ID'])
non_tv_users_aux = all_users - tv_users
non_tv_users = watch_data[watch_data['USER_ID'].isin(non_tv_users_aux)]

# Program kind by type of user
non_tv_program_counts = non_tv_users['PROGRAM_KIND'].value_counts()
regular_tv_program_counts = regular_tv_users['PROGRAM_KIND'].value_counts()

# Watch days by type of user

weekday_mapping = {
    0: 'Monday',
    1: 'Tuesday',
    2: 'Wednesday',
    3: 'Thursday',
    4: 'Friday',
    5: 'Saturday',
    6: 'Sunday'
}

non_tv_weekday_counts = watch_data[watch_data['USER_ID'].isin(non_tv_users['USER_ID'])]['DATE_DAY'].dt.dayofweek.value_counts().rename(weekday_mapping)
regular_tv_weekday_counts = watch_data[watch_data['USER_ID'].isin(regular_tv_users['USER_ID'])]['DATE_DAY'].dt.dayofweek.value_counts().rename(weekday_mapping)

# Number of users by age group
non_tv_users_age_group_distribution = users_data_cleaned[users_data_cleaned['ID'].isin(non_tv_users['USER_ID'])]['AGE_GROUP'].value_counts()
regular_tv_consumers_age_group_distribution = users_data_cleaned[users_data_cleaned['ID'].isin(regular_tv_users['USER_ID'])]['AGE_GROUP'].value_counts()

"""### Viewing duration"""

# Avg viewing duration time per user per month
total_duration_per_user = watch_data.groupby('USER_ID')['DURATION'].sum()
average_hours_per_month_per_user = (total_duration_per_user /3600 ) /(12)

# Plot results
plt.hist(average_hours_per_month_per_user, bins=20, color='skyblue', edgecolor='black')

plt.title('Distribution of Average Monthly Viewing Hours per User')
plt.xlabel('Average Monthly Viewing Hours')
plt.ylabel('Number of Users')


plt.show()

tv_watch_data = watch_data[watch_data['DEVICE_TYPE'] == 'tv']

# Average viewing duration per user in seconds
avg_duration_regular = regular_tv_users['DURATION'].mean()
avg_duration_non_tv = non_tv_users['DURATION'].mean()
avg_duration_tv = tv_watch_data['DURATION'].mean()
avg_duration = watch_data['DURATION'].mean()

# Convert to minutes
avg_duration_regular_minutes = int(avg_duration_regular / 60)
avg_duration_non_tv_minutes = int(avg_duration_non_tv / 60)
avg_duration_tv_minutes = int(avg_duration_tv / 60)
avg_duration_minutes = int(avg_duration / 60)

print("Average viewing duration for regular users:", avg_duration_regular_minutes, "minutes")
print("Average viewing duration for non-tv users:", avg_duration_non_tv_minutes, "minutes")
print("Average viewing duration tv users:", avg_duration_tv_minutes, "minutes")
print("Average viewing all users:", avg_duration_minutes, "minutes")

# Create list
avg_durations = [avg_duration_non_tv_minutes,avg_duration_tv_minutes,avg_duration_regular_minutes]
labels = ['Utilisateurs non-TV', 'Utilisateurs TV', 'Utilisateurs de TV réguliers']

# Create graph
plt.figure(figsize=(14, 8))

# Create not filled bars
for i in range(0, len(labels)-1):
    plt.bar(labels[i], avg_durations[i], color='none', edgecolor='#fac308ff', linewidth=3)

# Create filled bar
plt.bar(labels[2], avg_durations[2], color='#fac308ff', linewidth=0)

# Duration
for i, duration in enumerate(avg_durations):
    plt.text(i, duration + 2, f'{duration} min', ha='center', fontsize=32)

# Other adjustements
plt.grid(False)
plt.gca().axes.get_yaxis().set_visible(False)
plt.box(False)

plt.axhline(color='black', linewidth=1)

plt.ylabel('Durée de visionnement moyenne', fontsize=25)
plt.title('Durée de visionnement moyenne par groupe d\'utilisateurs', fontsize=25, y=1.1)

# Show graph
plt.xticks(range(len(labels)), labels, fontsize=25, y=-0.05)
plt.tight_layout()
plt.show()

"""### Viewing frequency"""

# Calculate the total number of viewing events
total_regular_viewing_events = len(regular_tv_users)
total_non_regular_viewing_events = len(non_tv_users)

# Calculate  unique users
total_unique_users_regular = len(regular_tv_users['USER_ID'].unique())
total_unique_users_non_tv = len(non_tv_users['USER_ID'].unique())

# Calcular la frecuencia promedio de visualización por usuario
average_frequency_per_user_regular = total_regular_viewing_events / total_unique_users_regular
average_frequency_per_user_non_tv = total_non_regular_viewing_events / total_unique_users_non_tv

# Determine the minimum and maximum dates in the 'DATE_DAY' column
start_date = watch_data['DATE_DAY'].min()
end_date = watch_data['DATE_DAY'].max()
dataset_duration = end_date - start_date
num_months = (end_date.year - start_date.year) * 12 + (end_date.month - start_date.month) + 1

# Calculate  avg frequency of viewing per week
average_frequency_per_user_per_month_regular = round(average_frequency_per_user_regular / num_months,2)
average_frequency_per_user_per_month_non_tv = round(average_frequency_per_user_non_tv / num_months,2)

print("Average frequency of viewing per month for regular users:", average_frequency_per_user_per_month_regular)
print("Average frequency of viewing per month for non-regular users:", average_frequency_per_user_per_month_non_tv)

# Calcular el número total de visualizaciones
total_viewing_events = len(watch_data)

# Calcular el número total de usuarios únicos
total_unique_users = len(watch_data['USER_ID'].unique())

# Calcular la frecuencia promedio de visualización por usuario
average_frequency_per_user = total_viewing_events / total_unique_users

# Dividir la frecuencia promedio de visualización por usuario por la duración total del conjunto de datos en meses
average_frequency_per_user_per_month = average_frequency_per_user / num_months

print("Average frequency of viewing per month per user in the watch data table:", average_frequency_per_user_per_month)

"""## Create visualizations"""

# Order days
weekday_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
non_tv_weekday_counts = non_tv_weekday_counts.reindex(weekday_order)
regular_tv_weekday_counts = regular_tv_weekday_counts.reindex(weekday_order)

# Order ages
age_group_order = ['0-18 years', '18-25 years', '25-35 years', '35-45 years', '45-60 years', '60-95 years']
non_tv_users_age_group_distribution = non_tv_users_age_group_distribution.reindex(age_group_order)
regular_tv_consumers_age_group_distribution = regular_tv_consumers_age_group_distribution.reindex(age_group_order)

# Create subplots
fig, axs = plt.subplots(1, 3, figsize=(15, 5))

# PROGRAM_KIND
program_kind_df = pd.concat([non_tv_program_counts, regular_tv_program_counts], axis=1, keys=['Non-TV Consumers', 'Regular TV Consumers'])
program_kind_df.plot(kind='bar', ax=axs[0], color=['blue', 'green'], title='Program Kind', rot=45)

# WEEKDAY
weekday_df = pd.concat([non_tv_weekday_counts, regular_tv_weekday_counts], axis=1, keys=['Non-TV Consumers', 'Regular TV Consumers'])
weekday_df.plot(kind='bar', ax=axs[1], color=['blue', 'green'], title='Weekday', rot=45)

# AGE_GROUP
age_group_df = pd.concat([non_tv_users_age_group_distribution, regular_tv_consumers_age_group_distribution], axis=1, keys=['Non-TV Consumers', 'Regular TV Consumers'])
age_group_df.plot(kind='bar', ax=axs[2], color=['blue', 'green'], title='Age Group', rot=45)

# Plot
plt.tight_layout()
plt.show()

"""## Age distribution"""

# Filter only device_type TV
tv_watchers = watch_data[watch_data['DEVICE_TYPE'] == 'tv']

# Join with users_data_cleaned
tv_watchers_with_age = pd.merge(tv_watchers, users_data_cleaned, left_on='USER_ID', right_on='ID', how='left')

# Obtain age
tv_watchers_age = tv_watchers_with_age['AGE']

# Create histogram
plt.figure(figsize=(10, 6))
hist = plt.hist(tv_watchers_age, bins=20, color='skyblue', edgecolor='black', alpha=0.7)

# Calculate percentages
n = len(tv_watchers_age)
bin_edges = hist[1]
bin_centers = 0.5 * (bin_edges[:-1] + bin_edges[1:])
bin_widths = bin_edges[1:] - bin_edges[:-1]
percentage = [(count / n) * 100 for count in hist[0]]

# Add labels
for center, count, width, percent in zip(bin_centers, hist[0], bin_widths, percentage):
    plt.text(center, count + 0.5, f'{percent:.2f}%', ha='center', va='bottom', fontsize=10)

plt.xlabel('Age', fontsize=14)
plt.ylabel('Frequency', fontsize=14)
plt.title('Distribution of Ages of TV Viewers', fontsize=16)

# Plot
plt.show()

# Merge watch data with user data to include age group information for each view
watch_data_with_age = pd.merge(watch_data, users_data_cleaned[['ID', 'AGE', 'AGE_GROUP']], left_on='USER_ID', right_on='ID', how='left')

# Calculate age distribution for users
age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts(normalize=True).sort_index() * 100

# Display Results for Users
print("Age Distribution for All Users (Percentage)")
print()
print("Age Group | Users (%)")
for age_group in age_distribution_users.index:
    user_percentage = age_distribution_users.loc[age_group]
    print(f"{age_group:<13} | {user_percentage:.2f}%")

# Calculate the average age for each device type
average_age_by_device = round(watch_data_with_age.groupby('DEVICE_TYPE')['AGE'].mean(),2)
average_age_total_watchers = round(watch_data_with_age['AGE'].mean(),2)
print()
# Display the results
print("Average Age by Device Type:")
print(average_age_by_device)
print()

print("Average Age of watchers:")
print(average_age_total_watchers)

print()
# Calculate and display age distribution for each device type
device_types = watch_data_with_age['DEVICE_TYPE'].dropna().unique()

fig, axs = plt.subplots(1, len(device_types), figsize=(20, 5))

for i, device_type in enumerate(device_types):
    # Filter data for the current device type
    data_for_device_type = watch_data_with_age[watch_data_with_age['DEVICE_TYPE'] == device_type]

    # Calculate age distribution for the current device type
    age_distribution_device_type = (data_for_device_type['AGE_GROUP']
                                    .value_counts(normalize=True)
                                    .sort_index() * 100)

    # Display Results for the current device type
    if isinstance(device_type, str):
        print(f"Age Distribution for {device_type.capitalize()} Users (Percentage)")
        print()
        print("Age Group | Users (%)")
        for age_group in age_distribution_device_type.index:
            device_percentage = age_distribution_device_type.get(age_group, 0)
            print(f"{age_group:<13} | {device_percentage:.2f}%")
        print()

        # Plot histogram for the current device type
        axs[i].bar(age_distribution_device_type.index, age_distribution_device_type.values, color='skyblue')
        axs[i].set_title(f'{device_type.capitalize()} Users')
        axs[i].set_xlabel('Age Group')
        axs[i].set_xticklabels(age_distribution_device_type.index, rotation=90, ha = 'center')
        axs[i].set_ylabel('Percentage')

plt.show()

tv_watchers_with_age = pd.merge(watch_data, users_data_cleaned, left_on='USER_ID', right_on = 'ID', how='left')
tv_watchers_age = tv_watchers_with_age['AGE']

# Group the information by device and age
grouped_by_device = tv_watchers_with_age.groupby('DEVICE_TYPE')['AGE']

# Create subplots for each device type
fig, axes = plt.subplots(nrows=len(grouped_by_device), figsize=(10, 6 * len(grouped_by_device)))

for i, (device, ages) in enumerate(grouped_by_device):
    ax = axes[i] if len(grouped_by_device) > 1 else axes  # Manejar el caso de un solo dispositivo
    ax.hist(ages, bins=20, color='skyblue', edgecolor='black', alpha=0.7)
    ax.set_xlabel('Age', fontsize=14)
    ax.set_ylabel('Frequency', fontsize=14)
    ax.set_title(f'Age distribution for {device.upper()}', fontsize=16)
    ax.grid(True)

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

tv_watchers_with_age = pd.merge(watch_data, users_data_cleaned, left_on='USER_ID', right_on='ID', how='left')

# Group the information by device and age
grouped_by_device = tv_watchers_with_age.groupby('DEVICE_TYPE')['AGE']

# Create subplots for each device type
fig, ax = plt.subplots(figsize=(10, 6))

# Define a color palette for each device type
palette = sns.color_palette('husl', n_colors=len(grouped_by_device))

for i, (device, ages) in enumerate(grouped_by_device):
    # Plot the histogram for each device type
    sns.histplot(data=ages, color=palette[i], bins=20, kde=False, stat='count', fill=False, line_kws={'linewidth': 2}, ax=ax)

# Labels and title
ax.set_xlabel('Age', fontsize=14)
ax.set_ylabel('Count', fontsize=14)
ax.set_title('Frequency Distribution of Ages for Each Device Type', fontsize=16)
ax.legend(grouped_by_device.groups.keys())  # Add legend with device types
ax.grid(True)

plt.tight_layout()
plt.show()

from matplotlib import cm, rcParams
!pip install joypy
import joypy

# Colors
tv_color = '#ff7b7a'
phone_color = '#2078b4'
desktop_color = '#a8cfe4'
tablet_color = '#35a12f'
smart_display_color = '#b2df8a'

# Fusión de los DataFrames 'watch_data' y 'users_data_cleaned' en la columna 'USER_ID'
merged_data = pd.merge(watch_data, users_data_cleaned, left_on='USER_ID', right_on='ID', how='left')

# Agrupar los datos fusionados por 'DEVICE_TYPE' y calcular la media y la desviación estándar de las edades para cada tipo de dispositivo
device_age_stats = merged_data.groupby('DEVICE_TYPE')['AGE'].agg(['mean', 'std'])

# Calcular el tamaño
device_type_counts = watch_data['DEVICE_TYPE'].value_counts()

# Diccionario para almacenar los tamaños
size_by_device_type = {}

# Iteración para asignar tamaños
for device_type, count in device_type_counts.items():
    size_by_device_type[device_type] = count

# Crear un DataFrame para almacenar los valores de loc, scale y size calculados para cada tipo de dispositivo
device_params = pd.DataFrame({
    'DEVICE_TYPE': device_age_stats.index,
    'loc': device_age_stats['mean'],
    'scale': device_age_stats['std'],
    'size': [size_by_device_type.get(device_type, 0) for device_type in device_age_stats.index]
})

# Configuración de los parámetros globales de la fuente
rcParams['font.size'] = 10

colors = [desktop_color, phone_color,smart_display_color  , tablet_color,tv_color]

# Crear el joyplot utilizando los colores específicos para cada dispositivo
fig, ax = joypy.joyplot(data=merged_data, by='DEVICE_TYPE', column='AGE', figsize=(6, 4), grid=True, color=colors,
                        overlap=1, xlim=(10, 90), linecolor='black', linewidth=1,
                        fade=True, background='white',
                        title='Distribution of Age by Device Type')



# Mostrar el joyplot
plt.show()

# Filter watch_data to get only the rows where device_type is 'tv'
tv_watch_data = watch_data[watch_data['DEVICE_TYPE'] == 'tv']

# Join the filtered table tv_watch_data with users_data_cleaned to get the age of TV viewers
tv_watch_data_with_age = pd.merge(tv_watch_data, users_data_cleaned[['ID', 'AGE']], left_on='USER_ID', right_on='ID', how='left')

# Average age of TV viewers
average_age_tv_viewers = tv_watch_data_with_age['AGE'].mean()

# Filter subscriptions_data to get only the rows where subscription_end_date is null
active_subscriptions_data = subscriptions_data[pd.isnull(subscriptions_data['SUBSCRIPTION_END_DATE'])]

# Join the filtered table active_subscriptions_data with users_data_cleaned to get the age of TV subscribers
tv_subscribers_with_age = pd.merge(active_subscriptions_data, users_data_cleaned[['ID', 'AGE']], left_on='USER_ID', right_on='ID', how='left')

# Average age of TV subscribers
average_age_tv_subscribers = tv_subscribers_with_age['AGE'].mean()

# Results
print("Average age of TV viewers:", int(average_age_tv_viewers))
print("Average age of TV subscribers:", int(average_age_tv_subscribers))

"""# Users that didn't use the platform"""

# Verify if all watch_data users are in users_data

# Extract unique USER_IDs from Watch table
watch_data_cleaned = watch_data.dropna(subset=['USER_ID'])

# Check if all users who have viewed content are in the users table
all_users_in_watch = watch_data_cleaned['USER_ID'].isin(users_data['ID']).all()

if all_users_in_watch:
      print("All users who have viewed content are present in the users table.")
else:
      print("Not all users who have viewed content are present in the users table.")

# Calculate the number of users who have never watched content
num_users_never_watched = total_users - watch_data['USER_ID'].nunique()
num_users_watched = watch_data['USER_ID'].nunique()
# Calculate the percentage of users who have never watched content
percentage_users_never_watched = (num_users_never_watched / total_users) * 100
percentage_users_watched = (num_users_watched / total_users) * 100

# Print results
print("Users that didn't watch any content:", num_users_never_watched)
print("Users that watched content:", num_users_watched)
print("Total users:", total_users)
print("Percentage of users who have never watched content: {:.2f}%".format(percentage_users_never_watched))
print("Percentage of users who have  watched content: {:.2f}%".format(percentage_users_watched))

"""# Subscriptions analysis"""

# Read values for subscriptions

print(subscriptions_data['PRODUCT_NAME'].unique())

"""## Users classification by subscription status"""

# Total Users total_users

# Total Active Subscribers
active_subscribers_list = subscriptions_data[subscriptions_data['SUBSCRIPTION_END_DATE'].isnull()]['USER_ID'].unique()

# Subscribers Who Canceled
subscribers_canceled_total_list = subscriptions_data[subscriptions_data['SUBSCRIPTION_END_DATE'].notnull()]['USER_ID'].unique()
subscribers_canceled_list = set(subscribers_canceled_total_list) - set(active_subscribers_list)

# Users that never had a subscription
users_never_subscribed_list = set(users_data['ID']) - set(subscriptions_data['USER_ID'])

# Totals
total_subscribers = len(active_subscribers_list)
total_canceled_subscribers = len(subscribers_canceled_list)
total_never_subscribed = len(users_never_subscribed_list)

# Percentages
percentage_active_subscribers = (total_subscribers / total_users) * 100
percentage_canceled_subscribers = (total_canceled_subscribers / total_users) * 100
percentage_never_subscribed = (total_never_subscribed / total_users) * 100

# Mostrar resultados
print("Total Users:", total_users)
print("Active Subscribers:", total_subscribers)
print("Canceled Subscribers:", total_canceled_subscribers)
print("Never Subscribed:", total_never_subscribed)
print("Percentage of Active Subscribers:", round(percentage_active_subscribers, 2), "%")
print("Percentage of Canceled Subscribers:", round(percentage_canceled_subscribers, 2), "%")
print("Percentage of Never Subscribed:", round(percentage_never_subscribed, 2), "%")
print()

# Pie chart data
labels = ['Abonnés actifs', 'Abonnés annulés', 'Jamais abonnés']
sizes = [percentage_active_subscribers, percentage_canceled_subscribers, percentage_never_subscribed]
colors = ['#99ff99', '#ff9999', '#66b3ff']
explode = (0.1, 0, 0)  # Highlight the first slice

# Create pie chart
plt.figure(figsize=(8, 6))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)
plt.title('Classifications des utilisateurs')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

# Show pie chart
plt.show()

"""## Watchers classification by subscription status"""

# Total number of records in watch_data
total_watch_records = len(watch_data)

# Users in the watch_data table
watch_users = set(watch_data['USER_ID'])

# Users in watch_data who are Active Subscribers
active_subscribers_watch = len(set(active_subscribers_list) & watch_users)

# Users in watch_data who are Canceled Subscribers
canceled_subscribers_watch = len(set(subscribers_canceled_list) & watch_users)

# Users in watch_data who are Never Subscribed
never_subscribed_watch = len(set(users_never_subscribed_list) & watch_users)

# Percentages
percentage_active_subscribers_watch = (active_subscribers_watch / len(watch_users)) * 100
percentage_canceled_subscribers_watch = (canceled_subscribers_watch / len(watch_users)) * 100
percentage_never_subscribed_watch = (never_subscribed_watch / len(watch_users)) * 100

# Display results
print("Total Watch Records:", total_watch_records)
print("Active Subscribers Watch:", active_subscribers_watch)
print("Canceled Subscribers Watch:", canceled_subscribers_watch)
print("Never Subscribed Watch:", never_subscribed_watch)
print("Percentage of Active Subscribers Watch:", round(percentage_active_subscribers_watch, 2), "%")
print("Percentage of Canceled Subscribers Watch:", round(percentage_canceled_subscribers_watch, 2), "%")
print("Percentage of Never Subscribed Watch:", round(percentage_never_subscribed_watch, 2), "%")
print()

# Define data
labels = ['Visionneurs Abonnés Actifs', 'Visionneurs Abonnés Annulés', 'Visionneurs Non Abonnés']
sizes = [active_subscribers_watch, canceled_subscribers_watch, never_subscribed_watch]
colors = ['#66ff99', '#ff6666', '#6666ff']
explode = (0.1, 0, 0)  # Highlight the first slice

# Create the pie chart
plt.figure(figsize=(8, 6))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.2f%%', startangle=140)
plt.title('Distribution des Enregistrements de Visionnage')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

# Show the pie chart
plt.show()

"""## Comparison between users and watchers in subscriptions"""

# Data for the first set
user_labels = ['Abonnés Actifs', 'Abonnés Annulés', 'Non Abonnés']
user_sizes = [percentage_active_subscribers, percentage_canceled_subscribers, percentage_never_subscribed]
user_colors = ['#99ff99', '#ff9999', '#66b3ff']

# Data for the second set
watch_labels = ['Abonnés Actifs Regardant', 'Abonnés Annulés Regardant', 'Non Abonnés Regardant']
watch_sizes = [percentage_active_subscribers_watch, percentage_canceled_subscribers_watch, percentage_never_subscribed_watch]
watch_colors = ['#99ff99', '#ff9999', '#66b3ff']  # Same colors as the first chart

# Create subplots
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(14, 6))

# Bar chart for distribution of users
axes[0].bar(user_labels, user_sizes, color=user_colors)
axes[0].set_title('USERS - Distribution des Utilisateurs')
axes[0].set_ylabel('Pourcentage')
axes[0].set_ylim(0, 100)  # Set y-axis limit for percentage range

# Annotate percentages in the bar chart for distribution of users
for i in range(len(user_labels)):
    axes[0].text(i, user_sizes[i] + 1, f'{user_sizes[i]:.2f}%', ha='center')

# Bar chart for distribution of watch records
axes[1].bar(watch_labels, watch_sizes, color=watch_colors)
axes[1].set_title('WATCH - Distribution des Enregistrements de Visionnage')
axes[1].set_ylabel('Pourcentage')
axes[1].set_ylim(0, 100)  # Set y-axis limit for percentage range

# Annotate percentages in the bar chart for distribution of watch records
for i in range(len(watch_labels)):
    axes[1].text(i, watch_sizes[i] + 1, f'{watch_sizes[i]:.2f}%', ha='center')

# Show the plots
plt.tight_layout()
plt.show()

"""## Type of subscription analysis"""

# Count the total number of users for each subscription type
total_subscription_counts = subscriptions_data['PRODUCT_NAME'].value_counts()

# Count the number of users who ended a subscription for each subscription type
cancelled_subscription_counts = subscriptions_data[subscriptions_data['SUBSCRIPTION_END_DATE'].notna()]['PRODUCT_NAME'].value_counts()

# Calculate the percentage of users who cancelled each subscription type
cancelled_subscription_percentages = (cancelled_subscription_counts / total_subscription_counts) * 100

# Calculate total subscriptions, cancellations, and active subscriptions
total_subscriptions = len(subscriptions_data)
total_cancellations = subscriptions_data['SUBSCRIPTION_END_DATE'].notna().sum()
total_active_subscriptions = total_subscriptions - total_cancellations

# Calculate percentages
percentage_cancellations = (total_cancellations / total_subscriptions) * 100
percentage_active_subscriptions = (total_active_subscriptions / total_subscriptions) * 100

print()
# Display the results in a table format
print("SUBSCRIPTION TYPE  | TOTAL USERS | CANCELLED USERS | ACTIVE USERS | CANCELLED % | ACTIVE % | ACTIVE % (of total users)")
print("-" * 110)  # Separator line
for subscription_type, total_count in total_subscription_counts.items():
    cancelled_count = cancelled_subscription_counts.get(subscription_type, 0)
    active_count = total_count - cancelled_count
    cancelled_percentage = (cancelled_count / total_count) * 100 if total_count > 0 else 0
    active_percentage = (active_count / total_count) * 100 if total_count > 0 else 0
    active_percentage_of_total_users = (active_count / total_users) * 100
    print(f"{subscription_type:<18} | {total_count:<11} | {cancelled_count:<15} | {active_count:<12} | {cancelled_percentage:>9.2f}% | {active_percentage:>8.2f}% | {active_percentage_of_total_users:>6.2f}%")

# Merge Users_data and Subscriptions_data
merged_data = pd.merge(users_data, subscriptions_data, left_on='ID', right_on='USER_ID', how='inner')

# Count the number of users for each subscription type
subscription_counts = merged_data['PRODUCT_NAME'].value_counts()

# Calculate the percentage of users for each subscription type
total_subscribed_users = len(merged_data)
subscription_percentages = (subscription_counts / total_subscribed_users) * 100

# Display the results in a table format
print("SUBSCRIPTION TYPE    |   PERCENTAGE OF USERS")
print("-" * 50)  # Separator line
for subscription_type, count in subscription_counts.items():
    print(f"{subscription_type:<20} | {subscription_percentages[subscription_type]:.2f}%")

# Set a sober color palette
merged_data = pd.merge(watch_data, users_data, left_on='USER_ID', right_on='ID', how='left')
merged_data = pd.merge(merged_data, subscriptions_data, left_on='ID', right_on='USER_ID', how='inner')

# Filter rows in merged_data where DEVICE_TYPE is 'tv'
merged_data_tv = merged_data[merged_data['DEVICE_TYPE'] == 'tv']

# Count the number of users for each subscription type for TV
subscription_counts_tv = merged_data_tv['PRODUCT_NAME'].value_counts()

# Calculate the percentage of users for each subscription type for TV
total_subscribed_users_tv = len(merged_data_tv)
subscription_percentages_tv = (subscription_counts_tv / total_subscribed_users_tv) * 100

# Display the results in a table format
print("Subscriptions of TV users")
print()
print("SUBSCRIPTION TYPE  |  PERCENTAGE OF USERS")
print("-" * 50) #Separator
for subscription_type, count in subscription_counts_tv.items():
    print(f"{subscription_type:<20} | {subscription_percentages_tv[subscription_type]:.2f}%")
print()
print()
# Plot a pie chart with larger text
plt.figure(figsize=(3, 3))
plt.pie(subscription_counts_tv, labels=subscription_counts_tv.index)
plt.title('Percentage of Users for Each Subscription Type (TV)')
plt.axis('equal')
plt.show()

"""## Number of subscribers by device type"""

# Subscribed users
subscribed_users = subscriptions_data[pd.isnull(subscriptions_data['SUBSCRIPTION_END_DATE'])]['USER_ID']

# Not subscribed
not_subscribed_users = users_data[~users_data['ID'].isin(subscribed_users)]

# Obtain watch data for groups
subscribed_users_watch = watch_data[watch_data['USER_ID'].isin(subscribed_users)]
not_subscribed_users_watch = watch_data[~watch_data['USER_ID'].isin(subscribed_users)]

# Total users by device type
subscribed_users_per_device = subscribed_users_watch.groupby('DEVICE_TYPE')['USER_ID'].nunique()
not_subscribed_users_per_device = not_subscribed_users_watch.groupby('DEVICE_TYPE')['USER_ID'].nunique()

#  RESULTS
print("Subscribed:")
print(subscribed_users_per_device)

print("\n Not subscribed:")
print(not_subscribed_users_per_device)

# Percentage
subscribed_percentage_per_device = (subscribed_users_per_device / (subscribed_users_per_device + not_subscribed_users_per_device)) * 100
subscribed_percentage_per_device = subscribed_percentage_per_device.round(2)
not_subscribed_percentage_per_device = (not_subscribed_users_per_device / (subscribed_users_per_device + not_subscribed_users_per_device)) * 100
not_subscribed_percentage_per_device = not_subscribed_percentage_per_device.round(2)

# Total users per device
total_users_per_device = subscribed_users_per_device + not_subscribed_users_per_device

# Results
results_table = pd.DataFrame({
    'SUSCRIBED (%)': subscribed_percentage_per_device,
    'NOT SUSCRIBED (%)': not_subscribed_percentage_per_device,
    'TOTAL USERS': total_users_per_device
})

results_table = results_table.sort_values(by='SUSCRIBED (%)', ascending=False)

# Mostrar tabla
print("                  SUSCRIBED - NOT SUSCRIBED")
print(results_table)

# Filter tv users
not_subscribed_tv_watch_data = not_subscribed_users_watch[not_subscribed_users_watch['DEVICE_TYPE'] == 'tv']

# Filter time period
watch_data_from_august_2023 = not_subscribed_tv_watch_data[pd.to_datetime(not_subscribed_tv_watch_data['DATE_DAY']) >= pd.to_datetime('2023-07-01')]

# Number of users with time period filter
users_over_20_hours_per_month = watch_data_from_august_2023.groupby('USER_ID').apply(lambda x: (x['DURATION'].sum() / 3600) > 8).sum()

# Results
print("Number of TV users not suscribed that have watched more than 8 hours of content the last months:", users_over_20_hours_per_month)

"""## Subscriptions and cancellations analysis by date"""

# Convert the date lists to date objects
subscription_dates = subscriptions_data['SUBSCRIPTION_BEGIN_DATE'].dt.date
cancellation_dates = subscriptions_data['SUBSCRIPTION_END_DATE'].dropna().dt.date

# Convert the date lists to date objects
subscription_dates = pd.to_datetime(subscription_dates)
cancellation_dates = pd.to_datetime(cancellation_dates)

# Count subscriptions and cancellations per day
subscription_counts_daily = subscription_dates.groupby(subscription_dates.dt.to_period('D')).count()
cancellation_counts_daily = cancellation_dates.groupby(cancellation_dates.dt.to_period('D')).count()

# Calculate the difference between subscriptions and cancellations per day
difference_daily = subscription_counts_daily - cancellation_counts_daily

# Plot the curve of subscriptions, cancellations, and difference per day
plt.figure(figsize=(10, 6))
plt.plot(subscription_counts_daily.index.to_timestamp(), subscription_counts_daily.values, label='Subscriptions', color='blue')
plt.plot(cancellation_counts_daily.index.to_timestamp(), cancellation_counts_daily.values, label='Cancellations', color='red')
plt.plot(difference_daily.index.to_timestamp(), difference_daily.values, label='Difference', color='green', linestyle='--')
plt.title('Subscriptions, Cancellations, and Difference per Day')
plt.xlabel('Date')
plt.ylabel('Quantity')
plt.legend()
plt.grid(True)
plt.show()

# Count subscriptions and cancellations per month
subscription_counts_monthly = subscription_dates.groupby(subscription_dates.dt.to_period('M')).count()
cancellation_counts_monthly = cancellation_dates.groupby(cancellation_dates.dt.to_period('M')).count()

# Calculate the difference between subscriptions and cancellations per month
difference_monthly = subscription_counts_monthly - cancellation_counts_monthly

# Plot the curve of subscriptions, cancellations, and difference per month
plt.figure(figsize=(10, 6))
plt.plot(subscription_counts_monthly.index.to_timestamp(), subscription_counts_monthly.values, label='Subscriptions', color='blue')
plt.plot(cancellation_counts_monthly.index.to_timestamp(), cancellation_counts_monthly.values, label='Cancellations', color='red')
plt.plot(difference_monthly.index.to_timestamp(), difference_monthly.values, label='Difference', color='green', linestyle='--')
plt.title('Subscriptions, Cancellations, and Difference per Month')
plt.xlabel('Date')
plt.ylabel('Quantity')
plt.legend()
plt.grid(True)
plt.show()

# Define the start date for zooming in
start_date = pd.to_datetime('2022-01-01')

# Plot the curve of subscriptions, cancellations, and difference per month with zooming in
plt.figure(figsize=(10, 6))
plt.plot(subscription_counts_monthly.index.to_timestamp(), subscription_counts_monthly.values, label='Subscriptions', color='blue')
plt.plot(cancellation_counts_monthly.index.to_timestamp(), cancellation_counts_monthly.values, label='Cancellations', color='red')
plt.plot(difference_monthly.index.to_timestamp(), difference_monthly.values, label='Difference', color='green', linestyle='--')
plt.title('Subscriptions, Cancellations, and Difference per Month (Zoomed In)')
plt.xlabel('Date')
plt.ylabel('Quantity')
plt.xlim(start_date, None)  # Set the x-axis limit to start from the defined start date
plt.legend()
plt.grid(True)
plt.show()

"""## Subscriptions and cancellations by product name and date"""

# Subscription and cancellation dates
subscription_dates = pd.to_datetime(subscriptions_data['SUBSCRIPTION_BEGIN_DATE'].dt.to_period('M').dt.start_time)
cancellation_dates = pd.to_datetime(subscriptions_data['SUBSCRIPTION_END_DATE'].dropna().dt.to_period('M').dt.start_time)

# Subscription types
subscription_types = subscriptions_data['PRODUCT_NAME'].unique()

# Create subplots
fig, axs = plt.subplots(2, figsize=(10, 12), sharex=True)

# Iterations for plot
for subscription_type in subscription_types:
    # Filter dates
    subscription_dates_filtered = subscription_dates[subscriptions_data['PRODUCT_NAME'] == subscription_type]
    cancellation_dates_filtered = cancellation_dates[subscriptions_data['PRODUCT_NAME'] == subscription_type]

    # Count subscriptions and cancellations
    subscription_counts_monthly = subscription_dates_filtered.groupby(subscription_dates_filtered.dt.to_period('M')).count()
    cancellation_counts_monthly = cancellation_dates_filtered.groupby(cancellation_dates_filtered.dt.to_period('M')).count()

    # Plot subscriptions
    axs[0].plot(subscription_counts_monthly.index.to_timestamp(), subscription_counts_monthly.values, label=subscription_type)
    axs[0].set_title('Subscriptions per Month')
    axs[0].set_ylabel('Quantity')
    axs[0].legend()
    axs[0].grid(True)

    # Plot cancellations
    axs[1].plot(cancellation_counts_monthly.index.to_timestamp(), cancellation_counts_monthly.values, label=subscription_type)
    axs[1].set_title('Cancellations per Month')
    axs[1].set_xlabel('Date')
    axs[1].set_ylabel('Quantity')
    axs[1].legend()
    axs[1].grid(True)

plt.tight_layout()
plt.show()

"""# Age distribution and preferences"""

# Total Users and Unique Watchers
# Total users: total_users
# Unique watchers: unique_users_watch_list
# Total unique watchers: unique_users_watch

# Filter for Valid Birthdays
users_data_cleaned = users_data[users_data['BIRTHDAY'].notna()]

# Calculate Age in Years
if 'AGE' not in users_data_cleaned.columns:
    users_data_cleaned['AGE'] = (pd.to_datetime('now') - pd.to_datetime(users_data_cleaned['BIRTHDAY'])).dt.days // 365

# Filter for valid ages (considering age <= 95)
users_data_cleaned = users_data_cleaned[users_data_cleaned['AGE'] <= 95]

# Check for 'AGE' Column Existence
if 'AGE' not in users_data_cleaned.columns:
    print("Warning: 'AGE' column not found in filtered data. Age group creation skipped.")
else:
    # Define age ranges for grouping
    age_ranges = [(0, 18), (18, 25), (25, 35), (35, 45), (45, 60), (60, 95)]

    # Define age labels
    age_labels = ["0-18 years", "18-25 years", "25-35 years", "35-45 years", "45-60 years", "60-95 years"]

    # Create 'AGE_GROUP' column based on age ranges and labels
    users_data_cleaned['AGE_GROUP'] = pd.cut(users_data_cleaned['AGE'], bins=[x[0] for x in age_ranges] + [95], labels=age_labels)

    # Merge watch data with user data to include age group information for each view
    watch_data_with_age = pd.merge(watch_data, users_data_cleaned[['ID', 'AGE', 'AGE_GROUP']], left_on='USER_ID', right_on='ID', how='left')

    # Initialize variables outside the loop
    top_3_content_by_age = pd.DataFrame(columns=['AGE_GROUP', 'PROGRAM_KIND', 'view_count', 'percentage'])
    top_3_devices_by_age = pd.DataFrame(columns=['AGE_GROUP', 'DEVICE_TYPE', 'view_count', 'percentage'])

    # Analyze Content Preference by Age Group
    content_preference_by_age = watch_data_with_age.groupby(['AGE_GROUP', 'PROGRAM_KIND']).size().reset_index(name='view_count')
    total_views_by_age = content_preference_by_age.groupby('AGE_GROUP')['view_count'].sum()

    for age_group in content_preference_by_age['AGE_GROUP'].unique():
        age_group_data = content_preference_by_age[content_preference_by_age['AGE_GROUP'] == age_group]
        age_group_data['percentage'] = (age_group_data['view_count'] / total_views_by_age[age_group]) * 100
        top_3_content_by_age = top_3_content_by_age.append(age_group_data.sort_values('percentage', ascending=False).head(3), ignore_index=True)

    # Analyze Device Preference by Age Group
    device_preference_by_age = watch_data_with_age.groupby(['AGE_GROUP', 'DEVICE_TYPE']).size().reset_index(name='view_count')
    total_views_by_age = device_preference_by_age.groupby('AGE_GROUP')['view_count'].sum()

    for age_group in device_preference_by_age['AGE_GROUP'].unique():
        age_group_data = device_preference_by_age[device_preference_by_age['AGE_GROUP'] == age_group]
        age_group_data['percentage'] = (age_group_data['view_count'] / total_views_by_age[age_group]) * 100
        top_3_devices_by_age = top_3_devices_by_age.append(age_group_data.sort_values('percentage', ascending=False).head(3), ignore_index=True)

    # Calculate age distribution for users
    age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts(normalize=True).sort_index() * 100

    # Calculate age distribution for watchers (assuming 'USER_ID' is in watch_data)
    age_distribution_watchers = (watch_data_with_age['AGE_GROUP']
                                  .value_counts(normalize=True)
                                  .sort_index() * 100)

    # Display Results
    print("1. Age Distribution (Percentage)")
    print()
    print("Age Group | Users (%) | Watchers (%)")
    for age_group in age_distribution_users.index:
        user_percentage = age_distribution_users.loc[age_group]
        watcher_percentage = age_distribution_watchers.get(age_group, 0)  # Handle missing values
        print(f"{age_group:<10} | {user_percentage:.2f}% | {watcher_percentage:.2f}%")
    print()
    print("2. Top 3 Content Preferences by Age Group")
    print()

    print("Age Group | Content Type 1 | Percentage 1 | Content Type 2 | Percentage 2 | Content Type 3 | Percentage 3")
    for age_group, group_data in top_3_content_by_age.groupby('AGE_GROUP'):
        print(f"{age_group:<10} | {group_data.iloc[0]['PROGRAM_KIND']:<13} | {group_data.iloc[0]['percentage']:.2f}% | {group_data.iloc[1]['PROGRAM_KIND']:<13} | {group_data.iloc[1]['percentage']:.2f}% | {group_data.iloc[2]['PROGRAM_KIND']:<13} | {group_data.iloc[2]['percentage']:.2f}%")
    print()
    print("3. Top 3 Device Preferences by Age Group")
    print()

    print("Age Group | Device Type 1 | Percentage 1 | Device Type 2 | Percentage 2 | Device Type 3 | Percentage 3")
    for age_group, group_data in top_3_devices_by_age.groupby('AGE_GROUP'):
        print(f"{age_group:<10} | {group_data.iloc[0]['DEVICE_TYPE']:<13} | {group_data.iloc[0]['percentage']:.2f}% | {group_data.iloc[1]['DEVICE_TYPE']:<13} | {group_data.iloc[1]['percentage']:.2f}% | {group_data.iloc[2]['DEVICE_TYPE']:<13} | {group_data.iloc[2]['percentage']:.2f}%")

# Filter for Valid Birthdays
users_data_cleaned = users_data[users_data['BIRTHDAY'].notna()]

# Calculate Age in Years
users_data_cleaned['AGE'] = (pd.to_datetime('now') - pd.to_datetime(users_data_cleaned['BIRTHDAY'])).dt.days // 365

# Filter for valid ages (considering age <= 95)
users_data_cleaned = users_data_cleaned[users_data_cleaned['AGE'] <= 95]

# Define age ranges for grouping
age_ranges = [(0, 18), (18, 25), (25, 35), (35, 45), (45, 60), (60, 95)]

# Define age labels
age_labels = ["0-18 years", "18-25 years", "25-35 years", "35-45 years", "45-60 years", "60-95 years"]

# Create 'AGE_GROUP' column based on age ranges and labels
users_data_cleaned['AGE_GROUP'] = pd.cut(users_data_cleaned['AGE'], bins=[x[0] for x in age_ranges] + [age_ranges[-1][1]], labels=age_labels)

# Merge watch data with user data to include age group information for each view
watch_data_with_age = pd.merge(watch_data, users_data_cleaned[['ID', 'AGE', 'AGE_GROUP']], left_on='USER_ID', right_on='ID', how='left')

# Calculate age distribution for users
age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts(normalize=True).sort_index() * 100

# Display Results for Users
print("1. Age Distribution for All Users (Percentage)")
print()
print("Age Group | Users (%)")
for age_group in age_distribution_users.index:
    user_percentage = age_distribution_users.loc[age_group]
    print(f"{age_group:<13} | {user_percentage:.2f}%")
print()

# Calculate and display age distribution for each device type
device_types = watch_data_with_age['DEVICE_TYPE'].dropna().unique()

fig, axs = plt.subplots(1, len(device_types), figsize=(15, 5))

for i, device_type in enumerate(device_types):
    # Filter data for the current device type
    data_for_device_type = watch_data_with_age[watch_data_with_age['DEVICE_TYPE'] == device_type]

    # Calculate age distribution for the current device type
    age_distribution_device_type = (data_for_device_type['AGE_GROUP']
                                    .value_counts(normalize=True)
                                    .sort_index() * 100)

    # Display Results for the current device type
    if isinstance(device_type, str):
        print(f" {device_type.capitalize()} Users (Percentage)")
        print()
        print("Age Group | Users (%)")
        for age_group in age_distribution_device_type.index:
            device_percentage = age_distribution_device_type.get(age_group, 0)  # Handle missing values
            print(f"{age_group:<13} | {device_percentage:.2f}%")
        print()

        # Plot histogram for the current device type
        axs[i].bar(age_distribution_device_type.index, age_distribution_device_type.values, color='skyblue')
        axs[i].set_title(f'Age Distribution for {device_type.capitalize()} Users')
        axs[i].set_xlabel('Age Group')
        axs[i].set_ylabel('Percentage')
        axs[i].set_xticklabels(age_distribution_device_type.index, rotation=90)  # Rotate X-axis labels


plt.tight_layout()
plt.show()

# Calculate age distribution for users
age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts(normalize=True).sort_index() * 100

# Calculate age distribution for watchers (assuming 'USER_ID' is in watch_data)
age_distribution_watchers = (watch_data_with_age['AGE_GROUP']
                                .value_counts(normalize=True)
                                .sort_index() * 100)

# Set bar width
bar_width = 0.4

# Create a bar chart
plt.figure(figsize=(10, 6))

# Define the positions for the bars
positions = np.arange(len(age_distribution_users))

# Plot user age distribution
plt.barh(positions - bar_width/2, age_distribution_users, height=bar_width, color='lightblue', label='Users')

# Plot watcher age distribution
plt.barh(positions + bar_width/2, age_distribution_watchers, height=bar_width, color='lightcoral', label='Watchers', alpha=0.7)

# Add percentages for user age distribution
for i, (age_group, percentage) in enumerate(age_distribution_users.items()):
    plt.text(percentage, i - bar_width/2, f'{int(percentage)}%', ha='left', va='center', fontsize=10)

# Add percentages for watcher age distribution
for i, (age_group, percentage) in enumerate(age_distribution_watchers.items()):
    plt.text(percentage, i + bar_width/2, f'{int(percentage)}%', ha='right', va='center', fontsize=10)

# Customize the plot
plt.xlabel('Percentage')
plt.ylabel('Age Group')
plt.title('Age Distribution')
plt.legend()
plt.grid(axis='x')

# Adjust y-axis ticks and labels
plt.yticks(np.arange(len(age_distribution_users)), age_distribution_users.index)

# Show the plot
plt.show()

# Merge subscriptions data with user data to include age group information for each subscriber
subscriptions_data_cleaned = subscriptions_data[pd.isnull(subscriptions_data['SUBSCRIPTION_END_DATE'])]  # Filter for active subscriptions
subscriptions_data_with_age = pd.merge(subscriptions_data_cleaned, users_data_cleaned[['ID', 'AGE', 'AGE_GROUP']], left_on='USER_ID', right_on='ID', how='left')

# Calculate age distribution for users
age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts(normalize=True).sort_index() * 100

# Calculate age distribution for watchers (assuming 'USER_ID' is in watch_data)
age_distribution_watchers = (watch_data_with_age['AGE_GROUP']
                                .value_counts(normalize=True)
                                .sort_index() * 100)

# Calculate age distribution for subscribers
age_distribution_subscribers = (subscriptions_data_with_age['AGE_GROUP']
                                    .value_counts(normalize=True)
                                    .sort_index() * 100)

# Set bar width
bar_width = 0.3

# Create a bar chart
plt.figure(figsize=(10, 6))

# Define the positions for the bars
positions = np.arange(len(age_distribution_users))

# Plot user age distribution
plt.barh(positions - bar_width, age_distribution_users, height=bar_width, color='lightblue', label='Users')

# Plot watcher age distribution
plt.barh(positions, age_distribution_watchers, height=bar_width, color='lightcoral', label='Watchers', alpha=0.7)

# Plot subscriber age distribution
plt.barh(positions + bar_width, age_distribution_subscribers, height=bar_width, color='lightgreen', label='Subscribers', alpha=0.7)

# Add percentages for user age distribution
for i, (age_group, percentage) in enumerate(age_distribution_users.items()):
    plt.text(percentage, i - bar_width, f'{int(percentage)}%', ha='left', va='center', fontsize=10)

# Add percentages for watcher age distribution
for i, (age_group, percentage) in enumerate(age_distribution_watchers.items()):
    plt.text(percentage, i, f'{int(percentage)}%', ha='right', va='center', fontsize=10)

# Add percentages for subscriber age distribution
for i, (age_group, percentage) in enumerate(age_distribution_subscribers.items()):
    plt.text(percentage, i + bar_width, f'{int(percentage)}%', ha='right', va='center', fontsize=10)

# Customize the plot
plt.xlabel('Percentage')
plt.ylabel('Age Group')
plt.title('Age Distribution')
plt.legend()
plt.grid(axis='x')

# Adjust y-axis ticks and labels
plt.yticks(np.arange(len(age_distribution_users)), age_distribution_users.index)

# Show the plot
plt.show()

# Calculate age distribution for users (cantidad)
age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts().sort_index()

# Calculate age distribution for watchers (cantidad)
age_distribution_watchers = watch_data_with_age['AGE_GROUP'].value_counts().sort_index()


# Calculate age distribution for subscribers (cantidad)
age_distribution_subscribers = subscriptions_data_with_age['AGE_GROUP'].value_counts().sort_index()

# Set bar width
bar_width = 0.3

# Create a bar chart
plt.figure(figsize=(10, 6))

# Define the positions for the bars
positions = np.arange(len(age_distribution_users))

# Plot user age distribution
plt.barh(positions - bar_width, age_distribution_users, height=bar_width, color='lightblue', label='Users')

# Plot watcher age distribution
plt.barh(positions, age_distribution_watchers, height=bar_width, color='lightcoral', label='Watchers', alpha=0.7)

# Plot subscriber age distribution
plt.barh(positions + bar_width, age_distribution_subscribers, height=bar_width, color='lightgreen', label='Subscribers', alpha=0.7)

# Add counts for user age distribution
for i, (age_group, count) in enumerate(age_distribution_users.items()):
    plt.text(count, i - bar_width, f'{count}', ha='left', va='center', fontsize=10)

# Add counts for watcher age distribution
for i, (age_group, count) in enumerate(age_distribution_watchers.items()):
    plt.text(count, i, f'{count}', ha='right', va='center', fontsize=10)

# Add counts for subscriber age distribution
for i, (age_group, count) in enumerate(age_distribution_subscribers.items()):
    plt.text(count, i + bar_width, f'{count}', ha='right', va='center', fontsize=10)

# Customize the plot
plt.xlabel('Count')
plt.ylabel('Age Group')
plt.title('Age Distribution')
plt.legend()
plt.grid(axis='x')

# Adjust y-axis ticks and labels
plt.yticks(np.arange(len(age_distribution_users)), age_distribution_users.index)

# Show the plot
plt.show()

"""## Distribution of users tenure and preferences by tenure"""

from datetime import datetime

# Calculate the users' tenure
users_data_cleaned['ACCOUNT_CREATION_DATE'] = pd.to_datetime(users_data_cleaned['ACCOUNT_CREATION_DATE'])
current_date = datetime.now()
users_data_cleaned['User_Age'] = (current_date - users_data_cleaned['ACCOUNT_CREATION_DATE']).dt.days / 365

# Visualize the distribution of user tenure
plt.figure(figsize=(10, 6))
ax = sns.histplot(users_data_cleaned['User_Age'], bins=range(0, 11, 1), kde=True, color='skyblue')

# Add gray vertical lines every six months
for year in range(0, 10):
    ax.axvline(x=year + 0.5, color='gray', linestyle='--', linewidth=0.5)

# Add percentages on top of the bars
total_users_cl = users_data_cleaned.shape[0]
for p in ax.patches:
    percentage = '{:.0f}%'.format(100 * p.get_height() / total_users_cl)  # Modified to remove decimals
    x = p.get_x() + p.get_width() / 2
    y = p.get_height()
    ax.annotate(percentage, (x, y), ha='center', va='bottom')

plt.title('Distribution de l\'ancienneté des utilisateurs')
plt.xlabel('Ancienneté (années)')
plt.ylabel('Nombre d\'utilisateurs')
plt.xticks(range(0, 11))
plt.yticks(range(0, 10001, 1000))  # Set upper limit on y-axis to 10,000 users
plt.xlim(0, 10)  # Set upper limit on x-axis to 10 years
plt.ylim(0, 10000)  # Set upper limit on y-axis to 10,000 users
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

# Merge dataframes to get antiquity information
merged_data = pd.merge(users_data, watch_data, left_on='ID', right_on='USER_ID', how='inner')

# Convert account creation date to datetime
merged_data['ACCOUNT_CREATION_DATE'] = pd.to_datetime(merged_data['ACCOUNT_CREATION_DATE'])

# Calculate user antiquity in days
merged_data['USER_ANTIQUITY'] = (pd.to_datetime('now') - merged_data['ACCOUNT_CREATION_DATE']).dt.days

# Define antiquity ranges
antiquity_bins = [0, 730, 1460, 2190, 2920, float('inf')]  # Ranges: 0-2 years, 2-4 years, 4-6 years, 6-8 years, 8+ years
antiquity_labels = ['0-2 years', '2-4 years', '4-6 years', '6-8 years', '8+ years']

# Assign antiquity group to each user based on account creation date
merged_data['USER_ANTIQUITY_GROUP'] = pd.cut(merged_data['USER_ANTIQUITY'], bins=antiquity_bins, labels=antiquity_labels)

# Analyze content preference by antiquity group
content_preference_by_antiquity_group = merged_data.groupby(['USER_ANTIQUITY_GROUP', 'PROGRAM_KIND']).size().unstack(fill_value=0)

# Convert to percentage of users
total_users_by_antiquity_group = merged_data['USER_ANTIQUITY_GROUP'].value_counts()
content_preference_by_antiquity_group_percentage = content_preference_by_antiquity_group.div(total_users_by_antiquity_group, axis=0) * 100

# Define tenure groups and their explanations
tenure_groups = {
    "0-2 years": "Less than 2 years on the platform",
    "2-4 years": "Between 2 and 4 years on the platform",
    "4-6 years": "Between 4 and 6 years on the platform",
    "6-8 years": "Between 6 and 8 years on the platform",
    "8+ years": "More than 8 years on the platform"
}

# Create a table to display the top 5 preferred content types and their percentages within each tenure group
content_preference_table = []

for tenure_group, content_preferences in content_preference_by_antiquity_group_percentage.iterrows():
    top_5_contents = content_preferences.sort_values(ascending=False).head(5)
    total_users_in_group = total_users_by_antiquity_group.get(tenure_group, 0)
    for content, percentage in top_5_contents.items():
        content_preference_table.append([tenure_group, content, f'{percentage:.2f}%'])

# Sort the content preference table by tenure group and percentage of people
content_preference_table.sort(key=lambda x: (list(tenure_groups.keys()).index(x[0]), -float(x[2][:-1])))

# Display the table with properly aligned columns and visual separation between groups
print("TENURE GROUP |  CONTENT PREFERRED  |   PERCENTAGE OF PEOPLE")
print("-" * 60)  # Horizontal line to separate header
for i, row in enumerate(content_preference_table):
    # Print tenure group with visual separation
    if i > 0 and content_preference_table[i][0] != content_preference_table[i-1][0]:
        print("-" * 60)  # Horizontal line between tenure groups
    print(f"{row[0]:<13} | {row[1]:<18} | {row[2]:>10}")

"""# Devices and asset types analysis"""

# Calculate view percentage by device type
content_by_device = watch_data.groupby(['DEVICE_TYPE', 'PROGRAM_KIND']).size().unstack(fill_value=0)

content_by_device_percentage = content_by_device.div(content_by_device.sum(axis=1), axis=0) * 100

# Color palette
pastel_colors = ['#FF9999', '#66B2FF', '#99FF99', '#FFCC99', '#FFD700']

# Plot results
ax = content_by_device_percentage.plot(kind='bar', stacked=True, figsize=(12, 6), color=pastel_colors)
plt.title('Content Viewed by Device Type (Percentage)')
plt.xlabel('Device Type')
plt.ylabel('Percentage')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(title='Program Kind', bbox_to_anchor=(1.05, 1), loc='upper left')

# Percent of each bar
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate(f'{height:.2f}%', (x + width / 2, y + height / 2), ha='center', va='center', color='black')

plt.tight_layout()
plt.show()

# Asset by age range
asset_by_age_range = watch_data_with_age.groupby(pd.cut(watch_data_with_age['AGE'], bins=[x[0] for x in age_ranges] + [95], labels=age_labels))['ASSET_TYPE'].value_counts().unstack(fill_value=0)

# Transpose
asset_by_age_range_transposed = asset_by_age_range.T

# Plot results
asset_by_age_range_transposed.plot(kind='line', figsize=(12, 6))
plt.title('Asset Type Viewed by Age Group')
plt.xlabel('Asset Type')
plt.ylabel('Frequency')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(title='Age Group', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""## Asset type by age"""

# Asset type by age
total_by_age_range = asset_by_age_range.sum(axis=1)
asset_by_age_range_percentage = asset_by_age_range.div(total_by_age_range, axis=0) * 100

# Color palette
pastel_colors = ['#FF9999', '#66B2FF', '#99FF99', '#FFCC99', '#FFD700']

# Plot resolts
ax = asset_by_age_range_percentage.plot(kind='bar', stacked=True, figsize=(12, 6), color=pastel_colors)
plt.title('Asset Type Viewed by Age Group (Percentage)')
plt.xlabel('Age Group')
plt.ylabel('Percentage')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(title='Asset Type', bbox_to_anchor=(1.05, 1), loc='upper left')

# Percentages in bars
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate(f'{height:.2f}%', (x + width / 2, y + height / 2), ha='center', va='center', color='black')

plt.tight_layout()
plt.show()

"""## Subscriptions by age"""

# Function to assign age group labels
def get_age_group_label(age):
    for i, (start, end) in enumerate(age_ranges):
        if start <= age < end:
            return age_labels[i]
    return "Unknown"

# Apply the function to get the age group for each user
users_data_cleaned['AGE_GROUP'] = users_data_cleaned['AGE'].apply(get_age_group_label)

# Calculate the total count of users and users with subscriptions for each age group
age_group_counts = users_data_cleaned['AGE_GROUP'].value_counts().reindex(age_labels, fill_value=0)
age_group_subscription_counts = users_data_cleaned[users_data_cleaned['ID'].isin(subscriptions_data['USER_ID'])]['AGE_GROUP'].value_counts().reindex(age_labels, fill_value=0)

# Calculate the percentage of users with subscriptions for each age group
percentage_with_subscriptions = (age_group_subscription_counts / age_group_counts * 100).fillna(0)

# Create the stacked bar chart
plt.figure(figsize=(10, 6))

# Plot the stacked bars for users with subscriptions
plt.bar(age_labels, percentage_with_subscriptions, color='skyblue', label='Avec Abonnements', alpha=0.7)

# Plot the stacked bars for users without subscriptions on top of the previous bars
plt.bar(age_labels, 100 - percentage_with_subscriptions, bottom=percentage_with_subscriptions, color='salmon', label='Sans Abonnements', alpha=0.7)

# Add percentages for each age group
for i, (age_label, percentage) in enumerate(zip(age_labels, percentage_with_subscriptions)):
    plt.text(i, percentage / 2, f"{percentage:.0f}%", ha='center', va='center', color='white')
    plt.text(i, 100 - (100 - percentage) / 2, f"{100 - percentage:.0f}%", ha='center', va='center', color='white')

# Configure the chart
plt.title("Pourcentage de Personnes avec et sans Abonnements par Groupe d'Âge")
plt.xlabel('Groupe d\'Âge')
plt.ylabel('Pourcentage')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()

# Show the chart
plt.show()

"""## Users, subscriptions, cancellations and never-subscribed by age"""

# Subscriptions, cancellations and never-subscribed by age
age_group_user_counts = []
age_group_subscription_counts = []
age_group_desubscription_counts = []

for age_range in age_ranges:
    age_group = users_data_cleaned[(users_data_cleaned['AGE'] >= age_range[0]) & (users_data_cleaned['AGE'] < age_range[1])]
    age_group_users = len(age_group)

    # Contar las suscripciones en este grupo de edad
    subscriptions_in_age_group = subscriptions_data[subscriptions_data['USER_ID'].isin(age_group['ID'])]
    age_group_subscriptions = len(subscriptions_in_age_group)

    # Calcular desuscripciones restando suscripciones del total de usuarios en este grupo de edad
    age_group_desubscriptions = age_group_users - age_group_subscriptions

    # Agregar los recuentos a las listas respectivas
    age_group_user_counts.append(age_group_users)
    age_group_subscription_counts.append(age_group_subscriptions)
    age_group_desubscription_counts.append(age_group_desubscriptions)

# Prepare data to graph
bar_width = 0.25
index = np.arange(len(age_labels))

# Create graph
plt.figure(figsize=(10, 6))

# Plot bars
plt.bar(index - bar_width, age_group_subscription_counts, width=bar_width, color='skyblue', label='Abonnements')
for i, count in enumerate(age_group_subscription_counts):
    plt.text(i - bar_width, count, str(count), ha='center', va='bottom')

plt.bar(index, age_group_desubscription_counts, width=bar_width, color='orange', label='Désabonnements')
for i, count in enumerate(age_group_desubscription_counts):
    plt.text(i, count, str(count), ha='center', va='bottom')

plt.bar(index + bar_width, age_group_user_counts, width=bar_width, color='lightgreen', label='Utilisateurs')
for i, count in enumerate(age_group_user_counts):
    plt.text(i + bar_width, count, str(count), ha='center', va='bottom')

# Add labels and title
plt.title('Nombre d\'Abonnements, de Désabonnements et d\'Utilisateurs par Groupe d\'Âge')
plt.xlabel('Groupe d\'Âge')
plt.ylabel('Nombre')
plt.xticks(index, age_labels)
plt.legend()
plt.grid(True)

# Plot graph
plt.tight_layout()
plt.show()

# Filter tv subscribers
tv_subscribers = subscriptions_data[subscriptions_data['USER_ID'].isin(watch_data[watch_data['DEVICE_TYPE'] == 'tv']['USER_ID'])]
tv_subscribers_with_age = pd.merge(tv_subscribers, users_data_cleaned[['ID', 'AGE']], left_on='USER_ID', right_on='ID', how='left')

# Join data
tv_subscribers_with_age = pd.merge(tv_subscribers_with_age, watch_data[['USER_ID']], on='USER_ID', how='left')

# Average age of tv subscribers
average_age_tv_subscribers = tv_subscribers_with_age['AGE'].mean()

print("La edad promedio de los suscriptores que utilizan TV es:", round(average_age_tv_subscribers, 2))

# Identify subscriber users
subscriber_ids = subscriptions_data['USER_ID'].unique()

# Filter subscriber watch history and calculate the average duration per session
subscriber_watch_history = watch_data[watch_data['USER_ID'].isin(subscriber_ids)]
subscriber_avg_duration = subscriber_watch_history['DURATION'].mean() / 60  # Convert to minutes

# Filter non-subscriber watch history and calculate the average duration per session
non_subscriber_watch_history = watch_data[~watch_data['USER_ID'].isin(subscriber_ids)]
non_subscriber_avg_duration = non_subscriber_watch_history['DURATION'].mean() / 60  # Convert to minutes

# Calculate the average duration per session for all users
avg_duration_all_users = watch_data['DURATION'].mean() / 60  # Convert to minutes

print("Average duration per session for subscribers:", int(subscriber_avg_duration), "minutes")
print("Average duration per session for non-subscribers:", int(non_subscriber_avg_duration), "minutes")
print("Average duration per session for all users:", int(avg_duration_all_users), "minutes")

"""# User behaviour before subscribing and cancellating"""

# Convert dates to datetime objects
subscriptions_data['SUBSCRIPTION_BEGIN_DATE'] = pd.to_datetime(subscriptions_data['SUBSCRIPTION_BEGIN_DATE'])
watch_data['DATE_DAY'] = pd.to_datetime(watch_data['DATE_DAY'])

# Get unique months in the dataset
unique_months = watch_data['DATE_DAY'].dt.to_period('M').unique()

# Iterate over each month
for month_period in sorted(unique_months):  # Sort the months
    month_of_interest = month_period.strftime('%Y-%m')  # Get the year and month

    # Filter subscribers who subscribed in the month of interest
    subscribers_in_month = subscriptions_data[subscriptions_data['SUBSCRIPTION_BEGIN_DATE'].dt.to_period('M').astype(str) == month_of_interest]['USER_ID']

    # Filter watch history for subscribers in the month of interest
    subscriber_watch_history = watch_data[watch_data['USER_ID'].isin(subscribers_in_month)]

    # Calculate total duration per month for subscribers in the month of interest
    total_duration_per_month = subscriber_watch_history.groupby(subscriber_watch_history['DATE_DAY'].dt.to_period('M'))['DURATION'].sum() / 60  # Convert to minutes

    # Plot the data
    plt.figure(figsize=(5, 3))
    plt.plot(total_duration_per_month.index.astype(str), total_duration_per_month.values, marker='o', linestyle='-')
    plt.title(f'Total Duration per Month for Subscribers in {month_of_interest}')
    plt.xlabel('Month')
    plt.ylabel('Total Duration (minutes)')
    plt.grid(True)
    plt.xticks(rotation=45)

    # Add vertical line for subscription month
    subscription_month = subscriptions_data[subscriptions_data['SUBSCRIPTION_BEGIN_DATE'].dt.to_period('M').astype(str) == month_of_interest]['SUBSCRIPTION_BEGIN_DATE'].iloc[0]
    plt.axvline(x=subscription_month.strftime('%Y-%m'), color='r', linestyle='--', label='Subscription Month')

    # Add vertical lines for all months
    for month in unique_months:
        plt.axvline(x=month.strftime('%Y-%m'), color='gray', linestyle=':', alpha=0.5)

    plt.tight_layout()
    plt.legend()
    plt.show()

# Convert dates to datetime objects
subscriptions_data['SUBSCRIPTION_BEGIN_DATE'] = pd.to_datetime(subscriptions_data['SUBSCRIPTION_BEGIN_DATE'])
subscriptions_data['SUBSCRIPTION_END_DATE'] = pd.to_datetime(subscriptions_data['SUBSCRIPTION_END_DATE'])
watch_data['DATE_DAY'] = pd.to_datetime(watch_data['DATE_DAY'])

# Get unique months in the dataset
unique_months = watch_data['DATE_DAY'].dt.to_period('M').unique()

# Create subplots
fig, axes = plt.subplots(len(unique_months), 1, figsize=(5, 3 * len(unique_months)), sharex=True)

# Iterate over each month
for i, month_period in enumerate(sorted(unique_months)):  # Sort the months
    month_of_interest = month_period.strftime('%Y-%m')  # Get the year and month

    # Filter subscribers who subscribed in the month of interest
    cancellations_in_month = subscriptions_data[(subscriptions_data['SUBSCRIPTION_END_DATE'].dt.to_period('M').astype(str) == month_of_interest) & (~subscriptions_data['SUBSCRIPTION_END_DATE'].isnull())]['USER_ID']

    # Filter watch history for subscribers in the month of interest
    cancellation_watch_history = watch_data[watch_data['USER_ID'].isin(cancellations_in_month)]

    # Calculate total duration per month for subscribers in the month of interest
    total_duration_per_month = cancellation_watch_history.groupby(cancellation_watch_history['DATE_DAY'].dt.to_period('M'))['DURATION'].sum() / 60  # Convert to minutes

    # Plot the data
    axes[i].plot(total_duration_per_month.index.astype(str), total_duration_per_month.values, marker='o', linestyle='-')
    axes[i].set_title(f'Total Duration per Month for Cancellations in {month_of_interest}')
    axes[i].set_ylabel('Total Duration (minutes)')
    axes[i].grid(True)
    axes[i].tick_params(axis='x', rotation=45)

    # Add vertical line for cancellation month
    cancellation_month = subscriptions_data[(subscriptions_data['SUBSCRIPTION_END_DATE'].dt.to_period('M').astype(str) == month_of_interest) & (~subscriptions_data['SUBSCRIPTION_END_DATE'].isnull())]['SUBSCRIPTION_END_DATE'].iloc[0]
    axes[i].axvline(x=cancellation_month.strftime('%Y-%m'), color='r', linestyle='--', label='Cancellation Month')

    # Add vertical lines for all months
    for month in unique_months:
        axes[i].axvline(x=month.strftime('%Y-%m'), color='gray', linestyle=':', alpha=0.5)

    axes[i].legend()

plt.tight_layout()
plt.show()