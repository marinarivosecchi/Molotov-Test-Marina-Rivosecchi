# -*- coding: utf-8 -*-
"""Molotov.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DqpUvM_zVBgHZf3LjfY64ycfm1H82Eho
"""

# Commented out IPython magic to ensure Python compatibility.
# Import all packages and set plots to be embedded inline
import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns

# %matplotlib inline

# Suppress warnings from final output
import warnings
warnings.simplefilter("ignore")

# Load drive
from google.colab import drive
drive.mount('/content/drive')

# Load data

df1 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/channel.csv').iloc[:, 1:]
channel_data = df1

df2 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/subscriptions.csv').iloc[:, 1:]
subscriptions_data = df2

df3 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/users.csv').iloc[:, 1:]
users_data = df3

df4 = pd.read_csv('/content/drive/MyDrive/Programacion/Molotov/entretien_data_analyse/watch.csv').iloc[:, 1:]
watch_data = df4

channel_data.head()

subscriptions_data.head()

users_data.head()

watch_data.head()

channel_data.info()

channel_data['NAME'] = channel_data['NAME'].astype('string')
channel_data.info()

subscriptions_data.info()

subscriptions_data['USER_ID'] = subscriptions_data['USER_ID'].astype('string')
subscriptions_data['SUBSCRIPTION_BEGIN_DATE'] = pd.to_datetime(subscriptions_data['SUBSCRIPTION_BEGIN_DATE'])
subscriptions_data['SUBSCRIPTION_END_DATE'] = pd.to_datetime(subscriptions_data['SUBSCRIPTION_END_DATE'])
subscriptions_data['PRODUCT_NAME'] = subscriptions_data['PRODUCT_NAME'].astype('string')

subscriptions_data.info()

users_data['ID'] = users_data['ID'].astype('string')
users_data['BIRTHDAY'] = pd.to_datetime(users_data['BIRTHDAY'])
users_data['ACCOUNT_CREATION_DATE'] = pd.to_datetime(users_data['ACCOUNT_CREATION_DATE'])

users_data.info()

watch_data['DATE_DAY'] = pd.to_datetime(watch_data['DATE_DAY'])
watch_data['USER_ID'] = watch_data['USER_ID'].astype('string')
watch_data['DEVICE_TYPE'] = watch_data['DEVICE_TYPE'].astype('string')
watch_data['PROGRAM_KIND'] = watch_data['PROGRAM_KIND'].astype('string')
watch_data['ASSET_TYPE'] = watch_data['ASSET_TYPE'].astype('string')
watch_data['DURATION'] = watch_data['DURATION'].astype('float64')
watch_data['CHANNEL_ID'] = watch_data['CHANNEL_ID'].astype('float64')
watch_data['EVENT_ID'] = watch_data['EVENT_ID'].fillna(0)
watch_data['EVENT_ID'] = watch_data['EVENT_ID'].astype('int64')

watch_data.info()

# Chequear duplicados
duplicados_channel = channel_data.duplicated().sum()
print("Cantidad de filas duplicadas en Channel:", duplicados_channel)

# Chequear valores nulos o faltantes
valores_nulos_channel = channel_data.isnull().sum()
print("\nValores nulos en Channel:")
print(valores_nulos_channel)

# Chequear tipos de datos
tipos_de_datos_channel = channel_data.dtypes
print("\nTipos de datos en Channel:")
print(tipos_de_datos_channel)

# Chequear valores únicos
valores_unicos_channel = channel_data.nunique()
print("\nValores únicos en Channel:")
print(valores_unicos_channel)

# Explorar estadísticas descriptivas
estadisticas_channel = channel_data.describe()
print("\nEstadísticas descriptivas en Channel:")
print(estadisticas_channel)

# Chequear duplicados
duplicados_subscription = subscriptions_data.duplicated().sum()
print("Cantidad de filas duplicadas en Subscription:", duplicados_subscription)

# Chequear valores nulos o faltantes
valores_nulos_subscription = subscriptions_data.isnull().sum()
print("\nValores nulos en Subscription:")
print(valores_nulos_subscription)

# Chequear tipos de datos
tipos_de_datos_subscription = subscriptions_data.dtypes
print("\nTipos de datos en Subscription:")
print(tipos_de_datos_subscription)

# Chequear valores únicos
valores_unicos_subscription = subscriptions_data.nunique()
print("\nValores únicos en Subscription:")
print(valores_unicos_subscription)

# Explorar estadísticas descriptivas
estadisticas_subscription = subscriptions_data.describe()
print("\nEstadísticas descriptivas en Subscription:")
print(estadisticas_subscription)

# Chequear duplicados
duplicados_user = users_data.duplicated().sum()
print("Cantidad de filas duplicadas en User:", duplicados_user)

# Chequear valores nulos o faltantes
valores_nulos_user = users_data.isnull().sum()
print("\nValores nulos en User:")
print(valores_nulos_user)

# Chequear tipos de datos
tipos_de_datos_user = users_data.dtypes
print("\nTipos de datos en User:")
print(tipos_de_datos_user)

# Chequear valores únicos
valores_unicos_user = users_data.nunique()
print("\nValores únicos en User:")
print(valores_unicos_user)

# Explorar estadísticas descriptivas
estadisticas_user = users_data.describe()
print("\nEstadísticas descriptivas en User:")
print(estadisticas_user)

# Chequear duplicados
duplicados_watch = watch_data.duplicated().sum()
print("Cantidad de filas duplicadas en Watch:", duplicados_watch)

# Chequear valores nulos o faltantes
valores_nulos_watch = watch_data.isnull().sum()
print("\nValores nulos en Watch:")
print(valores_nulos_watch)

# Chequear tipos de datos
tipos_de_datos_watch = watch_data.dtypes
print("\nTipos de datos en Watch:")
print(tipos_de_datos_watch)

# Chequear valores únicos
valores_unicos_watch = watch_data.nunique()
print("\nValores únicos en Watch:")
print(valores_unicos_watch)

# Explorar estadísticas descriptivas
estadisticas_watch = watch_data.describe()
print("\nEstadísticas descriptivas en Watch:")
print(estadisticas_watch)



"""# Devices analysis

"""

# Values for device type
print(watch_data['DEVICE_TYPE'].unique())

# Total number of users
total_users = users_data.shape[0]
total_sessions = watch_data.shape[0]

# Group by device type
watch_grouped_device = watch_data.groupby("DEVICE_TYPE")

# Dictionary to save results
results = {}

# Calculate metrics for each device type
for DEVICE_TYPE in watch_grouped_device.groups.keys():

    df = watch_grouped_device.get_group(DEVICE_TYPE)
    unique_users_device = df["USER_ID"].nunique()
    sessions_device = df.shape[0]
    avg_duration = df["DURATION"].mean() / 60 # Convert a minutes
    share_users = (unique_users_device / total_users) * 100
    share_sessions = (sessions_device / total_sessions) * 100

    results[DEVICE_TYPE] = {
        "Unique users": unique_users_device,
        "Total sessions": sessions_device,
        "AVG Duration (minutes)": avg_duration,
        "Share of Users": share_users,
        "Share of Sessions": share_sessions,

    }

# Convert results to DataFrame
results_df = pd.DataFrame(results).T  # Transpose the DataFrame to have devices as rows

# Format numeric values with comma separators and no decimal places
results_df["Unique users"] = results_df["Unique users"].apply(lambda x: "{:,.0f}".format(x))
results_df["Total sessions"] = results_df["Total sessions"].apply(lambda x: "{:,.0f}".format(x))
results_df["AVG Duration (minutes)"] = results_df["AVG Duration (minutes)"].apply(lambda x: "{:,.2f}".format(x))
results_df["Share of Users"] = results_df["Share of Users"].apply(lambda x: "{:.2f}%".format(x))
results_df["Share of Sessions"] = results_df["Share of Sessions"].apply(lambda x: "{:.2f}%".format(x))

# Show results DataFrame
print(results_df.to_string(index=True))

# Verify if all watch_data users are in users_data

# Extract unique USER_IDs from Watch table
watch_data_cleaned = watch_data.dropna(subset=['USER_ID'])

# Check if all users who have viewed content are in the users table
all_users_in_watch = watch_data_cleaned['USER_ID'].isin(users_data['ID']).all()

if all_users_in_watch:
      print("All users who have viewed content are present in the users table.")
else:
      print("Not all users who have viewed content are present in the users table.")

"""Users that are registered but didn't watch any content"""

# Calculate the number of users who have never watched content
num_users_never_watched = total_users - len(set(watch_data['USER_ID']))

# Calculate the percentage of users who have never watched content
percentage_users_never_watched = (num_users_never_watched / total_users) * 100

# Print results
print("Users that didn't watch any content:", num_users_never_watched)
print("Total users:", total_users)
print("Percentage of users who have never watched content: {:.2f}%".format(percentage_users_never_watched))

"""# Subscriptions analysis"""

# Read values for subscriptions

print(subscriptions_data['PRODUCT_NAME'].unique())

# Total Users total_users

# Total Active Subscribers
active_subscribers_list = subscriptions_data[subscriptions_data['SUBSCRIPTION_END_DATE'].isnull()]['USER_ID'].unique()

# Subscribers Who Canceled
subscribers_canceled_total_list = subscriptions_data[subscriptions_data['SUBSCRIPTION_END_DATE'].notnull()]['USER_ID'].unique()
subscribers_canceled_list = set(subscribers_canceled_total_list) - set(active_subscribers_list)

# Users that never had a subscription
users_never_subscribed_list = set(users_data['ID']) - set(subscriptions_data['USER_ID'])

# Totals
total_subscribers = len(active_subscribers_list)
total_canceled_subscribers = len(subscribers_canceled_list)
total_never_subscribed = len(users_never_subscribed_list)

# Percentages
percentage_active_subscribers = (total_subscribers / total_users) * 100
percentage_canceled_subscribers = (total_canceled_subscribers / total_users) * 100
percentage_never_subscribed = (total_never_subscribed / total_users) * 100

# Mostrar resultados
print("Total Users:", total_users)
print("Active Subscribers:", total_subscribers)
print("Canceled Subscribers:", total_canceled_subscribers)
print("Never Subscribed:", total_never_subscribed)
print("Percentage of Active Subscribers:", round(percentage_active_subscribers, 2), "%")
print("Percentage of Canceled Subscribers:", round(percentage_canceled_subscribers, 2), "%")
print("Percentage of Never Subscribed:", round(percentage_never_subscribed, 2), "%")
print()

# Pie chart data
labels = ['Abonnés actifs', 'Abonnés annulés', 'Jamais abonnés']
sizes = [percentage_active_subscribers, percentage_canceled_subscribers, percentage_never_subscribed]
colors = ['#99ff99', '#ff9999', '#66b3ff']
explode = (0.1, 0, 0)  # Highlight the first slice

# Create pie chart
plt.figure(figsize=(8, 6))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)
plt.title('Classifications des utilisateurs')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

# Show pie chart
plt.show()

# Total number of records in watch_data
total_watch_records = len(watch_data)

# Users in the watch_data table
watch_users = set(watch_data['USER_ID'])

# Users in watch_data who are Active Subscribers
active_subscribers_watch = len(set(active_subscribers_list) & watch_users)

# Users in watch_data who are Canceled Subscribers
canceled_subscribers_watch = len(set(subscribers_canceled_list) & watch_users)

# Users in watch_data who are Never Subscribed
never_subscribed_watch = len(set(users_never_subscribed_list) & watch_users)

# Percentages
percentage_active_subscribers_watch = (active_subscribers_watch / len(watch_users)) * 100
percentage_canceled_subscribers_watch = (canceled_subscribers_watch / len(watch_users)) * 100
percentage_never_subscribed_watch = (never_subscribed_watch / len(watch_users)) * 100

# Display results
print("Total Watch Records:", total_watch_records)
print("Active Subscribers Watch:", active_subscribers_watch)
print("Canceled Subscribers Watch:", canceled_subscribers_watch)
print("Never Subscribed Watch:", never_subscribed_watch)
print("Percentage of Active Subscribers Watch:", round(percentage_active_subscribers_watch, 2), "%")
print("Percentage of Canceled Subscribers Watch:", round(percentage_canceled_subscribers_watch, 2), "%")
print("Percentage of Never Subscribed Watch:", round(percentage_never_subscribed_watch, 2), "%")
print()

# Define data
labels = ['Visionneurs Abonnés Actifs', 'Visionneurs Abonnés Annulés', 'Visionneurs Non Abonnés']
sizes = [active_subscribers_watch, canceled_subscribers_watch, never_subscribed_watch]
colors = ['#66ff99', '#ff6666', '#6666ff']
explode = (0.1, 0, 0)  # Highlight the first slice

# Create the pie chart
plt.figure(figsize=(8, 6))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.2f%%', startangle=140)
plt.title('Distribution des Enregistrements de Visionnage')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

# Show the pie chart
plt.show()

import matplotlib.pyplot as plt

# Data for the first set
user_labels = ['Abonnés Actifs', 'Abonnés Annulés', 'Non Abonnés']
user_sizes = [percentage_active_subscribers, percentage_canceled_subscribers, percentage_never_subscribed]
user_colors = ['#99ff99', '#ff9999', '#66b3ff']

# Data for the second set
watch_labels = ['Abonnés Actifs Regardant', 'Abonnés Annulés Regardant', 'Non Abonnés Regardant']
watch_sizes = [percentage_active_subscribers_watch, percentage_canceled_subscribers_watch, percentage_never_subscribed_watch]
watch_colors = ['#99ff99', '#ff9999', '#66b3ff']  # Same colors as the first chart

# Create subplots
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(14, 6))

# Bar chart for distribution of users
axes[0].bar(user_labels, user_sizes, color=user_colors)
axes[0].set_title('Distribution des Utilisateurs')
axes[0].set_ylabel('Pourcentage')
axes[0].set_ylim(0, 100)  # Set y-axis limit for percentage range

# Annotate percentages in the bar chart for distribution of users
for i in range(len(user_labels)):
    axes[0].text(i, user_sizes[i] + 1, f'{user_sizes[i]:.2f}%', ha='center')

# Bar chart for distribution of watch records
axes[1].bar(watch_labels, watch_sizes, color=watch_colors)
axes[1].set_title('Distribution des Enregistrements de Visionnage')
axes[1].set_ylabel('Pourcentage')
axes[1].set_ylim(0, 100)  # Set y-axis limit for percentage range

# Annotate percentages in the bar chart for distribution of watch records
for i in range(len(watch_labels)):
    axes[1].text(i, watch_sizes[i] + 1, f'{watch_sizes[i]:.2f}%', ha='center')

# Show the plots
plt.tight_layout()
plt.show()

# Count the total number of users for each subscription type
total_subscription_counts = subscriptions_data['PRODUCT_NAME'].value_counts()

# Count the number of users who ended a subscription for each subscription type
cancelled_subscription_counts = subscriptions_data[subscriptions_data['SUBSCRIPTION_END_DATE'].notna()]['PRODUCT_NAME'].value_counts()

# Calculate the percentage of users who cancelled each subscription type
cancelled_subscription_percentages = (cancelled_subscription_counts / total_subscription_counts) * 100

# Calculate total subscriptions, cancellations, and active subscriptions
total_subscriptions = len(subscriptions_data)
total_cancellations = subscriptions_data['SUBSCRIPTION_END_DATE'].notna().sum()
total_active_subscriptions = total_subscriptions - total_cancellations

# Calculate percentages
percentage_cancellations = (total_cancellations / total_subscriptions) * 100
percentage_active_subscriptions = (total_active_subscriptions / total_subscriptions) * 100

print()
# Display the results in a table format
print("SUBSCRIPTION TYPE  | TOTAL USERS | CANCELLED USERS | ACTIVE USERS | CANCELLED % | ACTIVE % | ACTIVE % (of total users)")
print("-" * 110)  # Separator line
for subscription_type, total_count in total_subscription_counts.items():
    cancelled_count = cancelled_subscription_counts.get(subscription_type, 0)
    active_count = total_count - cancelled_count
    cancelled_percentage = (cancelled_count / total_count) * 100 if total_count > 0 else 0
    active_percentage = (active_count / total_count) * 100 if total_count > 0 else 0
    active_percentage_of_total_users = (active_count / total_users) * 100
    print(f"{subscription_type:<18} | {total_count:<11} | {cancelled_count:<15} | {active_count:<12} | {cancelled_percentage:>9.2f}% | {active_percentage:>8.2f}% | {active_percentage_of_total_users:>6.2f}%")

# Merge Users_data and Subscriptions_data
merged_data = pd.merge(users_data, subscriptions_data, left_on='ID', right_on='USER_ID', how='inner')

# Count the number of users for each subscription type
subscription_counts = merged_data['PRODUCT_NAME'].value_counts()

# Calculate the percentage of users for each subscription type
total_users = len(merged_data)
subscription_percentages = (subscription_counts / total_users) * 100

# Display the results in a table format
print("SUBSCRIPTION TYPE     |   PERCENTAGE OF USERS")
print("-" * 50)  # Separator line
for subscription_type, count in subscription_counts.items():
    print(f"{subscription_type:<20} | {subscription_percentages[subscription_type]:.2f}%")

# Convert the date lists to date objects
subscription_dates = pd.to_datetime(subscription_dates)
cancellation_dates = pd.to_datetime(cancellation_dates)

# Count subscriptions and cancellations per day
subscription_counts_daily = subscription_dates.groupby(subscription_dates.dt.to_period('D')).count()
cancellation_counts_daily = cancellation_dates.groupby(cancellation_dates.dt.to_period('D')).count()

# Calculate the difference between subscriptions and cancellations per day
difference_daily = subscription_counts_daily - cancellation_counts_daily

# Plot the curve of subscriptions, cancellations, and difference per day
plt.figure(figsize=(10, 6))
plt.plot(subscription_counts_daily.index.to_timestamp(), subscription_counts_daily.values, label='Subscriptions', color='blue')
plt.plot(cancellation_counts_daily.index.to_timestamp(), cancellation_counts_daily.values, label='Cancellations', color='red')
plt.plot(difference_daily.index.to_timestamp(), difference_daily.values, label='Difference', color='green', linestyle='--')
plt.title('Subscriptions, Cancellations, and Difference per Day')
plt.xlabel('Date')
plt.ylabel('Quantity')
plt.legend()
plt.grid(True)
plt.show()

# Suppose you have subscription and cancellation data in two lists or arrays 'subscription_dates' and 'cancellation_dates'

subscription_dates = subscriptions_data['SUBSCRIPTION_BEGIN_DATE'].dt.date
cancellation_dates = subscriptions_data['SUBSCRIPTION_END_DATE'].dropna().dt.date

# Convert the date lists to date objects
subscription_dates = pd.to_datetime(subscription_dates)
cancellation_dates = pd.to_datetime(cancellation_dates)

# Count subscriptions and cancellations per month
subscription_counts_monthly = subscription_dates.groupby(subscription_dates.dt.to_period('M')).count()
cancellation_counts_monthly = cancellation_dates.groupby(cancellation_dates.dt.to_period('M')).count()

# Calculate the difference between subscriptions and cancellations per month
difference_monthly = subscription_counts_monthly - cancellation_counts_monthly

# Plot the curve of subscriptions, cancellations, and difference per month
plt.figure(figsize=(10, 6))
plt.plot(subscription_counts_monthly.index.to_timestamp(), subscription_counts_monthly.values, label='Subscriptions', color='blue')
plt.plot(cancellation_counts_monthly.index.to_timestamp(), cancellation_counts_monthly.values, label='Cancellations', color='red')
plt.plot(difference_monthly.index.to_timestamp(), difference_monthly.values, label='Difference', color='green', linestyle='--')
plt.title('Subscriptions, Cancellations, and Difference per Month')
plt.xlabel('Date')
plt.ylabel('Quantity')
plt.legend()
plt.grid(True)
plt.show()

# Define the start date for zooming in
start_date = pd.to_datetime('2022-01-01')  # Update the date as needed

# Plot the curve of subscriptions, cancellations, and difference per month with zooming in
plt.figure(figsize=(10, 6))
plt.plot(subscription_counts_monthly.index.to_timestamp(), subscription_counts_monthly.values, label='Subscriptions', color='blue')
plt.plot(cancellation_counts_monthly.index.to_timestamp(), cancellation_counts_monthly.values, label='Cancellations', color='red')
plt.plot(difference_monthly.index.to_timestamp(), difference_monthly.values, label='Difference', color='green', linestyle='--')
plt.title('Subscriptions, Cancellations, and Difference per Month (Zoomed In)')
plt.xlabel('Date')
plt.ylabel('Quantity')
plt.xlim(start_date, None)  # Set the x-axis limit to start from the defined start date
plt.legend()
plt.grid(True)
plt.show()

# Filtrar usuarios que han cancelado sus suscripciones
cancelled_subscriptions_users = subscriptions_data[subscriptions_data['SUBSCRIPTION_END_DATE'].notna()]

# Calcular actividad de visualización antes de la cancelación
cancelled_subscriptions_watch_data = pd.merge(cancelled_subscriptions_users, watch_data, on='USER_ID', how='inner')

# Definir un período de tiempo antes de la cancelación (60 días)
days_before_cancellation = 60

# Filtrar la actividad de visualización en el período de tiempo antes de la cancelación
cancelled_subscriptions_watch_data['DATE_DAY'] = pd.to_datetime(cancelled_subscriptions_watch_data['DATE_DAY'])
cancelled_subscriptions_watch_data = cancelled_subscriptions_watch_data[
    (cancelled_subscriptions_watch_data['SUBSCRIPTION_END_DATE'] - cancelled_subscriptions_watch_data['DATE_DAY']).dt.days <= days_before_cancellation
]

# Analizar la actividad de visualización
activity_summary = cancelled_subscriptions_watch_data.groupby(['USER_ID']).agg({
    'DURATION': 'sum',  # Suma de la duración de visualización
    'PROGRAM_KIND': lambda x: x.nunique()  # Número de tipos únicos de programas vistos
}).reset_index()

# Graficar la distribución de la duración de visualización
plt.figure(figsize=(10, 6))
plt.hist(activity_summary['DURATION'], bins=20, color='skyblue', edgecolor='black')
plt.title('Distribution of Viewing Duration before Subscription Cancellation')
plt.xlabel('Viewing Duration (seconds)')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

# Graficar la distribución del número de tipos únicos de programas vistos
plt.figure(figsize=(10, 6))
plt.hist(activity_summary['PROGRAM_KIND'], bins=10, color='lightgreen', edgecolor='black')
plt.title('Distribution of Unique Program Types Viewed before Subscription Cancellation')
plt.xlabel('Number of Unique Program Types')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

# Calculate counts and percentages for subscribed and non-subscribed users (devices, channels, content types)
merged_data = pd.merge(users_data_cleaned, subscriptions_data, left_on='ID', right_on='USER_ID', how='left')
merged_data = pd.merge(merged_data, watch_data, on='USER_ID', how='left')
merged_data = pd.merge(merged_data, channel_data, on='CHANNEL_ID', how='left')

# Devices
subscribed_device_counts = (merged_data[merged_data['SUBSCRIPTION_BEGIN_DATE'].notnull()]
                                .groupby('DEVICE_TYPE')['DEVICE_TYPE'].count().nlargest(5))
non_subscribed_device_counts = (merged_data[merged_data['SUBSCRIPTION_BEGIN_DATE'].isnull()]
                                    .groupby('DEVICE_TYPE')['DEVICE_TYPE'].count().nlargest(5))


subscribed_device_percentages = (subscribed_device_counts / subscribed_device_counts.sum()) * 100
non_subscribed_device_percentages = (non_subscribed_device_counts / non_subscribed_device_counts.sum()) * 100

# Channels
subscribed_channel_counts = (merged_data[merged_data['SUBSCRIPTION_BEGIN_DATE'].notnull()]
                             .groupby('CHANNEL_ID')['CHANNEL_ID'].count().nlargest(5))
non_subscribed_channel_counts = (merged_data[merged_data['SUBSCRIPTION_BEGIN_DATE'].isnull()]
                                .groupby('CHANNEL_ID')['CHANNEL_ID'].count().nlargest(5))

subscribed_channel_percentages = (subscribed_channel_counts / subscribed_channel_counts.sum()) * 100
non_subscribed_channel_percentages = (non_subscribed_channel_counts / non_subscribed_channel_counts.sum()) * 100

# Content Types
subscribed_asset_counts = (merged_data[merged_data['SUBSCRIPTION_BEGIN_DATE'].notnull()]
                            .groupby('ASSET_TYPE')['ASSET_TYPE'].count().nlargest(5))
non_subscribed_asset_counts = (merged_data[merged_data['SUBSCRIPTION_BEGIN_DATE'].isnull()]
                                .groupby('ASSET_TYPE')['ASSET_TYPE'].count().nlargest(5))

subscribed_asset_percentages = (subscribed_asset_counts / subscribed_asset_counts.sum()) * 100
non_subscribed_asset_percentages = (non_subscribed_asset_counts / non_subscribed_asset_counts.sum()) * 100


# Create the table data dictionary
table_data = {
    'Subscribed Users': [subscribed_users],
    'Non Subscribed Users': [non_subscribed_users]
}

# Add data for Top 5 Devices (format entries)
table_data['Top 5 Devices (Subscribed)'] = [f"{device}: {count} ({percentage:.2f}%)" for device, count, percentage in zip(subscribed_device_counts.index, subscribed_device_counts, subscribed_device_percentages)]
table_data['Top 5 Devices (Non Subscribed)'] = [f"{device}: {count} ({percentage:.2f}%)" for device, count, percentage in zip(non_subscribed_device_counts.index, non_subscribed_device_counts, non_subscribed_device_percentages)]

# Similar formatting for Top 5 Channels and Content Types
table_data['Top 5 Channels (Subscribed)'] = [f"{channel}: {count} ({percentage:.2f}%)" for channel, count, percentage in zip(subscribed_channel_counts.index, subscribed_channel_counts, subscribed_channel_percentages)]
table_data['Top 5 Channels (Non Subscribed)'] = [f"{channel}: {count} ({percentage:.2f}%)" for channel, count, percentage in zip(non_subscribed_channel_counts.index, non_subscribed_channel_counts, non_subscribed_channel_percentages)]
table_data['Top 5 Content type (Subscribed)'] = [f"{asset}: {count} ({percentage:.2f}%)" for asset, count, percentage in zip(subscribed_asset_counts.index, subscribed_asset_counts, subscribed_asset_percentages)]
table_data['Top 5 Content type (Non Subscribed)'] = [f"{asset}: {count} ({percentage:.2f}%)" for asset, count, percentage in zip(non_subscribed_asset_counts.index, non_subscribed_asset_counts, non_subscribed_asset_percentages)]

# Ensure all lists have at least 5 elements
for key in table_data:
    table_data[key] += [''] * (5 - len(table_data[key]))

# Create DataFrame
table_df = pd.DataFrame(table_data)

from prettytable import PrettyTable


# Separate information by category with spacing
print("USERS")  # Print category title with spacing
table = PrettyTable()
table.field_names = table_df.columns[:2]  # Select first two columns for Users
user_data = table_df[table_df.columns[:2]].values.tolist()  # Select all rows for first two columns
table.add_rows(user_data)  # Add all rows with selected columns
print(table)  # Print Users table

print("\nDEVICES")  # Print category title with spacing
table = PrettyTable()
table.field_names = table_df.columns[2:4]  # Select columns for Top 5 Devices
device_data = table_df[table_df.columns[2:4]].values.tolist()  # Select all rows for columns 2-4
table.add_rows(device_data)  # Add all rows with selected columns
print(table)  # Print Devices table

print("\nCHANNELS")  # Print category title with spacing
table = PrettyTable()
table.field_names = table_df.columns[4:6]  # Select columns for Top 5 Channels
channel_data = table_df[table_df.columns[4:6]].values.tolist()  # Select all rows for columns 4-5
table.add_rows(channel_data)  # Add all rows with selected columns
print(table)  # Print Channels table

print("\nCONTENT")  # Print category title with spacing
table = PrettyTable()
table.field_names = table_df.columns[6:]  # Select columns for Top 5 Content Types
content_data = table_df[table_df.columns[6:]].values.tolist()  # Select all rows for columns from 6th onwards
table.add_rows(content_data)  # Add all rows with selected columns
print(table)  # Print Content Types table

# Total Users and Unique Watchers
# Total users: total_users
# Unique watchers: unique_users_watch_list
# Total unique watchers: unique_users_watch

# Filter for Valid Birthdays
users_data_cleaned = users_data[users_data['BIRTHDAY'].notna()]

# Calculate Age in Years
if 'AGE' not in users_data_cleaned.columns:
    users_data_cleaned['AGE'] = (pd.to_datetime('now') - pd.to_datetime(users_data_cleaned['BIRTHDAY'])).dt.days // 365

# Filter for valid ages (considering age <= 95)
users_data_cleaned = users_data_cleaned[users_data_cleaned['AGE'] <= 95]

# Check for 'AGE' Column Existence
if 'AGE' not in users_data_cleaned.columns:
    print("Warning: 'AGE' column not found in filtered data. Age group creation skipped.")
else:
    # Define age ranges for grouping
    age_ranges = [(0, 18), (18, 25), (25, 35), (35, 45), (45, 60), (60, 95)]

    # Define age labels
    age_labels = ["0-18 years", "18-25 years", "25-35 years", "35-45 years", "45-60 years", "60-95 years"]

    # Create 'AGE_GROUP' column based on age ranges and labels
    users_data_cleaned['AGE_GROUP'] = pd.cut(users_data_cleaned['AGE'], bins=[x[0] for x in age_ranges] + [95], labels=age_labels)

    # Merge watch data with user data to include age group information for each view
    watch_data_with_age = pd.merge(watch_data, users_data_cleaned[['ID', 'AGE', 'AGE_GROUP']], left_on='USER_ID', right_on='ID', how='left')

    # Initialize variables outside the loop
    top_3_content_by_age = pd.DataFrame(columns=['AGE_GROUP', 'PROGRAM_KIND', 'view_count', 'percentage'])
    top_3_devices_by_age = pd.DataFrame(columns=['AGE_GROUP', 'DEVICE_TYPE', 'view_count', 'percentage'])

    # Analyze Content Preference by Age Group
    content_preference_by_age = watch_data_with_age.groupby(['AGE_GROUP', 'PROGRAM_KIND']).size().reset_index(name='view_count')
    total_views_by_age = content_preference_by_age.groupby('AGE_GROUP')['view_count'].sum()

    for age_group in content_preference_by_age['AGE_GROUP'].unique():
        age_group_data = content_preference_by_age[content_preference_by_age['AGE_GROUP'] == age_group]
        age_group_data['percentage'] = (age_group_data['view_count'] / total_views_by_age[age_group]) * 100
        top_3_content_by_age = top_3_content_by_age.append(age_group_data.sort_values('percentage', ascending=False).head(3), ignore_index=True)

    # Analyze Device Preference by Age Group
    device_preference_by_age = watch_data_with_age.groupby(['AGE_GROUP', 'DEVICE_TYPE']).size().reset_index(name='view_count')
    total_views_by_age = device_preference_by_age.groupby('AGE_GROUP')['view_count'].sum()

    for age_group in device_preference_by_age['AGE_GROUP'].unique():
        age_group_data = device_preference_by_age[device_preference_by_age['AGE_GROUP'] == age_group]
        age_group_data['percentage'] = (age_group_data['view_count'] / total_views_by_age[age_group]) * 100
        top_3_devices_by_age = top_3_devices_by_age.append(age_group_data.sort_values('percentage', ascending=False).head(3), ignore_index=True)

    # Calculate age distribution for users
    age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts(normalize=True).sort_index() * 100

    # Calculate age distribution for watchers (assuming 'USER_ID' is in watch_data)
    age_distribution_watchers = (watch_data_with_age['AGE_GROUP']
                                  .value_counts(normalize=True)
                                  .sort_index() * 100)

    # Display Results
    print("1. Age Distribution (Percentage)")
    print()
    print("Age Group | Users (%) | Watchers (%)")
    for age_group in age_distribution_users.index:
        user_percentage = age_distribution_users.loc[age_group]
        watcher_percentage = age_distribution_watchers.get(age_group, 0)  # Handle missing values
        print(f"{age_group:<10} | {user_percentage:.2f}% | {watcher_percentage:.2f}%")
    print()
    print("2. Top 3 Content Preferences by Age Group")
    print()

    print("Age Group | Content Type 1 | Percentage 1 | Content Type 2 | Percentage 2 | Content Type 3 | Percentage 3")
    for age_group, group_data in top_3_content_by_age.groupby('AGE_GROUP'):
        print(f"{age_group:<10} | {group_data.iloc[0]['PROGRAM_KIND']:<13} | {group_data.iloc[0]['percentage']:.2f}% | {group_data.iloc[1]['PROGRAM_KIND']:<13} | {group_data.iloc[1]['percentage']:.2f}% | {group_data.iloc[2]['PROGRAM_KIND']:<13} | {group_data.iloc[2]['percentage']:.2f}%")
    print()
    print("3. Top 3 Device Preferences by Age Group")
    print()

    print("Age Group | Device Type 1 | Percentage 1 | Device Type 2 | Percentage 2 | Device Type 3 | Percentage 3")
    for age_group, group_data in top_3_devices_by_age.groupby('AGE_GROUP'):
        print(f"{age_group:<10} | {group_data.iloc[0]['DEVICE_TYPE']:<13} | {group_data.iloc[0]['percentage']:.2f}% | {group_data.iloc[1]['DEVICE_TYPE']:<13} | {group_data.iloc[1]['percentage']:.2f}% | {group_data.iloc[2]['DEVICE_TYPE']:<13} | {group_data.iloc[2]['percentage']:.2f}%")

# Calculate age distribution for users

age_distribution_users = users_data_cleaned['AGE_GROUP'].value_counts(normalize=True).sort_index() * 100

# Calculate age distribution for watchers (assuming 'USER_ID' is in watch_data)
age_distribution_watchers = (watch_data_with_age['AGE_GROUP']
                                .value_counts(normalize=True)
                                .sort_index() * 100)

# Set bar width
bar_width = 0.4

# Create a bar chart
plt.figure(figsize=(10, 6))

# Define the positions for the bars
positions = np.arange(len(age_distribution_users))

# Plot user age distribution
plt.barh(positions - bar_width/2, age_distribution_users, height=bar_width, color='lightblue', label='Users')

# Plot watcher age distribution
plt.barh(positions + bar_width/2, age_distribution_watchers, height=bar_width, color='lightcoral', label='Watchers', alpha=0.7)

# Add percentages for user age distribution
for i, (age_group, percentage) in enumerate(age_distribution_users.items()):
    plt.text(percentage, i - bar_width/2, f'{int(percentage)}%', ha='left', va='center', fontsize=10)

# Add percentages for watcher age distribution
for i, (age_group, percentage) in enumerate(age_distribution_watchers.items()):
    plt.text(percentage, i + bar_width/2, f'{int(percentage)}%', ha='right', va='center', fontsize=10)

# Customize the plot
plt.xlabel('Percentage')
plt.ylabel('Age Group')
plt.title('Age Distribution')
plt.legend()
plt.grid(axis='x')

# Adjust y-axis ticks and labels
plt.yticks(np.arange(len(age_distribution_users)), age_distribution_users.index)

# Show the plot
plt.show()

from datetime import datetime

# Assuming we have an 'ACCOUNT_CREATION_DATE' column in users_data_cleaned
# with the users' account creation dates

# Calculate the users' tenure
users_data_cleaned['ACCOUNT_CREATION_DATE'] = pd.to_datetime(users_data_cleaned['ACCOUNT_CREATION_DATE'])
current_date = datetime.now()
users_data_cleaned['User_Age'] = (current_date - users_data_cleaned['ACCOUNT_CREATION_DATE']).dt.days / 365

# Visualize the distribution of user tenure
plt.figure(figsize=(10, 6))
ax = sns.histplot(users_data_cleaned['User_Age'], bins=range(0, 11, 1), kde=True, color='skyblue')

# Add gray vertical lines every six months
for year in range(0, 10):
    ax.axvline(x=year + 0.5, color='gray', linestyle='--', linewidth=0.5)

# Add percentages on top of the bars
total_users = users_data_cleaned.shape[0]
for p in ax.patches:
    percentage = '{:.0f}%'.format(100 * p.get_height() / total_users)  # Modified to remove decimals
    x = p.get_x() + p.get_width() / 2
    y = p.get_height()
    ax.annotate(percentage, (x, y), ha='center', va='bottom')

plt.title('Distribution de l\'ancienneté des utilisateurs')
plt.xlabel('Ancienneté (années)')
plt.ylabel('Nombre d\'utilisateurs')
plt.xticks(range(0, 11))
plt.yticks(range(0, 10001, 1000))  # Set upper limit on y-axis to 10,000 users
plt.xlim(0, 10)  # Set upper limit on x-axis to 10 years
plt.ylim(0, 10000)  # Set upper limit on y-axis to 10,000 users
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

# Merge dataframes to get antiquity information
merged_data = pd.merge(users_data, watch_data, left_on='ID', right_on='USER_ID', how='inner')

# Convert account creation date to datetime
merged_data['ACCOUNT_CREATION_DATE'] = pd.to_datetime(merged_data['ACCOUNT_CREATION_DATE'])

# Calculate user antiquity in days
merged_data['USER_ANTIQUITY'] = (pd.to_datetime('now') - merged_data['ACCOUNT_CREATION_DATE']).dt.days

# Define antiquity ranges
antiquity_bins = [0, 730, 1460, 2190, 2920, float('inf')]  # Ranges: 0-2 years, 2-4 years, 4-6 years, 6-8 years, 8+ years
antiquity_labels = ['0-2 years', '2-4 years', '4-6 years', '6-8 years', '8+ years']

# Assign antiquity group to each user based on account creation date
merged_data['USER_ANTIQUITY_GROUP'] = pd.cut(merged_data['USER_ANTIQUITY'], bins=antiquity_bins, labels=antiquity_labels)

# Analyze content preference by antiquity group
content_preference_by_antiquity_group = merged_data.groupby(['USER_ANTIQUITY_GROUP', 'PROGRAM_KIND']).size().unstack(fill_value=0)

# Convert to percentage of users
total_users_by_antiquity_group = merged_data['USER_ANTIQUITY_GROUP'].value_counts()
content_preference_by_antiquity_group_percentage = content_preference_by_antiquity_group.div(total_users_by_antiquity_group, axis=0) * 100

# Define tenure groups and their explanations
tenure_groups = {
    "0-2 years": "Less than 2 years on the platform",
    "2-4 years": "Between 2 and 4 years on the platform",
    "4-6 years": "Between 4 and 6 years on the platform",
    "6-8 years": "Between 6 and 8 years on the platform",
    "8+ years": "More than 8 years on the platform"
}

# Create a table to display the top 5 preferred content types and their percentages within each tenure group
content_preference_table = []

for tenure_group, content_preferences in content_preference_by_antiquity_group_percentage.iterrows():
    top_5_contents = content_preferences.sort_values(ascending=False).head(5)
    total_users_in_group = total_users_by_antiquity_group.get(tenure_group, 0)
    for content, percentage in top_5_contents.items():
        content_preference_table.append([tenure_group, content, f'{percentage:.2f}%'])

# Sort the content preference table by tenure group and percentage of people
content_preference_table.sort(key=lambda x: (list(tenure_groups.keys()).index(x[0]), -float(x[2][:-1])))

# Display the table with properly aligned columns and visual separation between groups
print("TENURE GROUP         |   CONTENT PREFERRED    |   PERCENTAGE OF PEOPLE")
print("-" * 60)  # Horizontal line to separate header
for i, row in enumerate(content_preference_table):
    # Print tenure group with visual separation
    if i > 0 and content_preference_table[i][0] != content_preference_table[i-1][0]:
        print("-" * 60)  # Horizontal line between tenure groups
    print(f"{row[0]:<20} | {row[1]:<20} | {row[2]:>20}")

"""# Analysis of Age"""

# Calcular porcentaje de visualización por tipo de dispositivo
content_by_device = watch_data.groupby(['DEVICE_TYPE', 'PROGRAM_KIND']).size().unstack(fill_value=0)

content_by_device_percentage = content_by_device.div(content_by_device.sum(axis=1), axis=0) * 100

# Definir una paleta de colores pastel
pastel_colors = ['#FF9999', '#66B2FF', '#99FF99', '#FFCC99', '#FFD700']

# Graficar los resultados como un gráfico de barras agrupadas
ax = content_by_device_percentage.plot(kind='bar', stacked=True, figsize=(12, 6), color=pastel_colors)
plt.title('Content Viewed by Device Type (Percentage)')
plt.xlabel('Device Type')
plt.ylabel('Percentage')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(title='Program Kind', bbox_to_anchor=(1.05, 1), loc='upper left')

# Agregar el porcentaje en cada barra
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate(f'{height:.2f}%', (x + width / 2, y + height / 2), ha='center', va='center', color='black')

plt.tight_layout()
plt.show()

# Agrupar por rango de edad y tipo de activo y calcular la frecuencia
asset_by_age_range = watch_data_with_age.groupby(pd.cut(watch_data_with_age['AGE'], bins=[x[0] for x in age_ranges] + [95], labels=age_labels))['ASSET_TYPE'].value_counts().unstack(fill_value=0)

# Transponer el DataFrame para tener los grupos de edad como columnas y los asset types como filas
asset_by_age_range_transposed = asset_by_age_range.T

# Graficar los resultados como un gráfico de líneas
asset_by_age_range_transposed.plot(kind='line', figsize=(12, 6))
plt.title('Asset Type Viewed by Age Group')
plt.xlabel('Asset Type')
plt.ylabel('Frequency')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(title='Age Group', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

total_by_age_range = asset_by_age_range.sum(axis=1)
asset_by_age_range_percentage = asset_by_age_range.div(total_by_age_range, axis=0) * 100


# Definir una paleta de colores pastel
pastel_colors = ['#FF9999', '#66B2FF', '#99FF99', '#FFCC99', '#FFD700']

# Graficar los resultados como un gráfico de barras agrupadas
ax = asset_by_age_range_percentage.plot(kind='bar', stacked=True, figsize=(12, 6), color=pastel_colors)
plt.title('Asset Type Viewed by Age Group (Percentage)')
plt.xlabel('Age Group')
plt.ylabel('Percentage')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(title='Asset Type', bbox_to_anchor=(1.05, 1), loc='upper left')

# Agregar el porcentaje en cada barra
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate(f'{height:.2f}%', (x + width / 2, y + height / 2), ha='center', va='center', color='black')

plt.tight_layout()
plt.show()

# Function to assign age group labels
def get_age_group_label(age):
    for i, (start, end) in enumerate(age_ranges):
        if start <= age < end:
            return age_labels[i]
    return "Unknown"

# Apply the function to get the age group for each user
users_data_cleaned['AGE_GROUP'] = users_data_cleaned['AGE'].apply(get_age_group_label)

# Calculate the total count of users and users with subscriptions for each age group
age_group_counts = users_data_cleaned['AGE_GROUP'].value_counts().reindex(age_labels, fill_value=0)
age_group_subscription_counts = users_data_cleaned[users_data_cleaned['ID'].isin(subscriptions_data['USER_ID'])]['AGE_GROUP'].value_counts().reindex(age_labels, fill_value=0)

# Calculate the percentage of users with subscriptions for each age group
percentage_with_subscriptions = (age_group_subscription_counts / age_group_counts * 100).fillna(0)

# Create the stacked bar chart
plt.figure(figsize=(10, 6))

# Plot the stacked bars for users with subscriptions
plt.bar(age_labels, percentage_with_subscriptions, color='skyblue', label='Avec Abonnements', alpha=0.7)

# Plot the stacked bars for users without subscriptions on top of the previous bars
plt.bar(age_labels, 100 - percentage_with_subscriptions, bottom=percentage_with_subscriptions, color='salmon', label='Sans Abonnements', alpha=0.7)

# Add percentages for each age group
for i, (age_label, percentage) in enumerate(zip(age_labels, percentage_with_subscriptions)):
    plt.text(i, percentage / 2, f"{percentage:.0f}%", ha='center', va='center', color='white')
    plt.text(i, 100 - (100 - percentage) / 2, f"{100 - percentage:.0f}%", ha='center', va='center', color='white')

# Configure the chart
plt.title("Pourcentage de Personnes avec et sans Abonnements par Groupe d'Âge")
plt.xlabel('Groupe d\'Âge')
plt.ylabel('Pourcentage')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()

# Show the chart
plt.show()

# Calcular la cantidad de usuarios, suscripciones y desuscripciones por grupo de edad
age_group_user_counts = []
age_group_subscription_counts = []
age_group_desubscription_counts = []

for age_range in age_ranges:
    age_group = users_data_cleaned[(users_data_cleaned['AGE'] >= age_range[0]) & (users_data_cleaned['AGE'] < age_range[1])]
    age_group_users = len(age_group)

    # Contar las suscripciones en este grupo de edad
    subscriptions_in_age_group = subscriptions_data[subscriptions_data['USER_ID'].isin(age_group['ID'])]
    age_group_subscriptions = len(subscriptions_in_age_group)

    # Calcular desuscripciones restando suscripciones del total de usuarios en este grupo de edad
    age_group_desubscriptions = age_group_users - age_group_subscriptions

    # Agregar los recuentos a las listas respectivas
    age_group_user_counts.append(age_group_users)
    age_group_subscription_counts.append(age_group_subscriptions)
    age_group_desubscription_counts.append(age_group_desubscriptions)

# Preparar los datos para el gráfico
bar_width = 0.25
index = np.arange(len(age_labels))

# Crear el gráfico de barras
plt.figure(figsize=(10, 6))

# Plotear las barras para las suscripciones
plt.bar(index - bar_width, age_group_subscription_counts, width=bar_width, color='skyblue', label='Abonnements')
for i, count in enumerate(age_group_subscription_counts):
    plt.text(i - bar_width, count, str(count), ha='center', va='bottom')

# Plotear las barras para las desuscripciones
plt.bar(index, age_group_desubscription_counts, width=bar_width, color='orange', label='Désabonnements')
for i, count in enumerate(age_group_desubscription_counts):
    plt.text(i, count, str(count), ha='center', va='bottom')

# Plotear las barras para los usuarios
plt.bar(index + bar_width, age_group_user_counts, width=bar_width, color='lightgreen', label='Utilisateurs')
for i, count in enumerate(age_group_user_counts):
    plt.text(i + bar_width, count, str(count), ha='center', va='bottom')

# Agregar etiquetas y título
plt.title('Nombre d\'Abonnements, de Désabonnements et d\'Utilisateurs par Groupe d\'Âge')
plt.xlabel('Groupe d\'Âge')
plt.ylabel('Nombre')
plt.xticks(index, age_labels)
plt.legend()
plt.grid(True)

# Mostrar el gráfico
plt.tight_layout()
plt.show()

# Filtrar usuarios no suscritos

# Users not suscribed
# List users_without_subscription_list
# Number Wpercent_users_without_subscription

# Contar canales únicos
channel_counts = no_subs.groupby(["USER_ID", "CHANNEL_ID"]).size().reset_index(name="ChannelCount")

# Contar dispositivos únicos
device_counts = no_subs.groupby(["USER_ID", "DEVICE_TYPE"]).size().reset_index(name="DeviceCount")

# Contar tipos de contenido únicos
content_counts = no_subs.groupby(["USER_ID", "PROGRAM_KIND"]).size().reset_index(name="ContentCount")

# Obtener los resultados
num_non_subscribed_channels = channel_counts.shape[0]
num_non_subscribed_devices = device_counts.shape[0]
num_non_subscribed_content_types = content_counts.shape[0]

print(f"Número de canales únicos vistos por usuarios no suscritos: {num_non_subscribed_channels}")
print(f"Número de dispositivos únicos utilizados por usuarios no suscritos: {num_non_subscribed_devices}")
print(f"Número de tipos de contenido únicos vistos por usuarios no suscritos: {num_non_subscribed_content_types}")